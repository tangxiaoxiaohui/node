<meta charset="utf-8">
<title>ES6</title>
一.块级作用域(let/const)
	1.不存在变量提升
	2.暂时性死区(在声明之前不可以使用)
	3.不允许重复声明
	4.let
	<script type="text/javascript">
		var arr = []
		for (let i = 0; i < 3; i++) {
			arr[i] = function () { console.log(i) }
		}
		arr[0]();
		// 个人理解for,let的解析.
		let i = 0;
		if(i < 3){
			arr[i] = function () { console.log(i) }	
		}
		i++;
		if(i < 3){
			arr[i] = function () { console.log(i) }	
		}
		i++;
		// 由于let i是块级作用域所以当for循环后
		// {}内的i 都是独立存在的.
	</script>
	5.const : 常量
		1.由const定义的为常量,不可更改
		2.由const定义的为常量为对象是.修改对象的内容是可以的.

二.变量的结构赋值(实质:模式匹配)
	1.数组的结构赋值(有序)
	<script type="text/javascript">
		var [a,b,c] = [1,2,3];
		let [d,e,f] = [1,2,3];
		// 结构不成功
		let [g,h,i] = [1,2];
		// 不完全结构
		let [j,k] = [1,2,3];
		// 默认值
		let [l = 1,m = 2] = [];
	</script>
	2.对象的结构赋值(无序),实际只是以对象的模式,进行模式匹配赋值而已.
	<script type="text/javascript">
		//***** a代表模式. b代表变量 *****//
		let {a,b} = {a:1,b:2};
		
		let {a:a,b:b} = {a:1,b:2}; // a=1,b=2
		let {a:b,b:a} = {a:1,b:2}; // a=2,b=1
		
		// 默认值
		let {a=1,b=1} = {};
		let {a:a=1,b:b=1} = {};
		
		// 对象的多次解构
		var obj = {
			person : {
				name : "xiaohui",
				like : ["eat",{"fulit":["banana","orange"]}]
			}
		}
		var {person:{name,like:[eat,{fulit:[a,b]}]}} = obj;
		var {person,person:{name,like,like:[eat,{fulit,fulit:[a,b]}]}} = obj;
		var {person:person,person:{name:name,like:like,like:[eat:eat,{fulit:fulit,fulit:[a:a,b:b]}]}} = obj;
	</script>
	3.默认值
		①.当进行结构赋值时,先进行模式匹配进行赋值,假如模式匹配失败,再取默认值.
		②.当模式匹配赋值绝对等于undefined(===undefined)时,取默认值.
	4.默认结构
	<script type="text/javascript">
		// 执行时,先把string解析为对象(浏览器内核自动完成的).
		var {length} = "length"; 		// length=6
		// 执行时,先把字符串解析为数组(浏览器内核自动完成的).
		var [a,b,c,d,e,f] = "123456"; 	// a=1,b=2,c=3,d=4,e=5,f=6
		var arr = [[1,2],[3,4],[5,6],[7,8]];
		// 令函数在赋值执行时,以结构的方式对形参进行赋值.
		function add([a,b]){
			console.log(a,b);
		}
		add([1,2]);

		arr.forEach(function([a,b]){
			console.log(a,b);	//  1,2  3,4  5,6  7,8  	
		})

		var {toString:num} = 1;
		var {toString:str} = "1";
		var {toString:arr} = [];
		var {toString:fun} = function(){};
		var a=	num === Number.prototype.toString;
		var	b=	str === String.prototype.toString;
		var	c=	arr === Array.prototype.toString;
		var	d=	fun === Function.prototype.toString;
	</script>

三.字符串的扩展
	1.模板字符串( `` )
		①.增强的字符串
		<script type="text/javascript">
			var div = `
				<div class="">
					<a href="javascript:0" class=""></a>
				</div>`
		</script>
		②.在字符串中添加变量或者表达式
		<script type="text/javascript">
			var user = {
				name:"xiaoming",
				age:18,
				like:"fulit",
			}
			var str = `name : ${user['name']} ,age : ${user['age']} ,like : ${user['like']}`;
			console.log(str);

			// 调用函数
			function get_name(){
				return "xiao hui"
			}
			console.log(`my name is ${get_name()}`);

			// 模板字符串嵌套
			var arr = [1,2,3,4,5];
			var str = `${arr.map(function(item,index){
				return `${index} : ${item}`
			})}`
			console.log(str);
		</script>
	
	2.标签模板
		①.标签模板实质——函数调用的特殊形式
		<script type="text/javascript">
			alert`呵呵`;

			name = "xiao hui";
			area = "Bei Jing";
			function test(name){
				console.log(name);	
				return name;
			}
			// ["", "", raw: Array[2]]
			test`${name}`;	

			// [" hello ", " ,welcome to ", "", raw: Array[3]]
			test` hello ${name} ,welcome to ${area}`;		
		</script>
		②.重要应用——过滤HTML字符串
		<script type="text/javascript">
				var demo = '<script>console.log("ok")<\/script>';

				filterHtml`<p> ${demo} </p>`;

				function filterHtml(arr){
					var str = arr[0],
						len = arguments.length;
					for(var i= 1;i<len;i++){
						str +=  arguments[i].replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
						str +=  arr[i];
					}
					return str; // "<p> &lt;script&gt;console.log("ok")&lt;/script&gt; </p>"
				}
		</script>

四.函数的扩展
	1.函数参数的默认值
		①.基本使用
		<script type="text/javascript">
			function demo(x,y=100){
				console.log(x,y);
			}
			demo(10);	// 10 100
		</script>
		②.结构赋值结合使用
		<script type="text/javascript">
			function demo({x,y=5}){
				console.log(x,y);
			}
			// demo()
			// error : 不能分解"未定义"或"null"的属性`x`
			// 也就是说在执行x值的结构时结构失败的error;
			// 与 var {x,y} = null error 相同
			demo({});			// undefined 5
			demo({x:1});		// 1 5
			demo({y:2});		// undefined 2
			demo({x:3,y:4});	// 3 4

			function f1({x=0,y=0} = {}){ 
				console.log(x,y);
			}
			f1();			// 0 0
			f1({});			// 0 0
			f1({x:1});		// 1 0
			f1({y:2});		// 0 2
			f1({x:3,y:4});	// 3 4

			function f2({x,y} = {x:0,y:0}){
				console.log(x,y);
			}
			f2();			// 0 0
			f2({});			// undefined undefined
			f2({x:1});		// 1 undefined
			f2({y:2});		// undefined 2
			f2({x:3,y:4});	// 3 4		
		</script>
	2.参数作用域以及注意事项
		<script type="text/javascript">
			let x =5;	
			function(){ 
				let x = 10;
			}
		</script>
	3.扩展运算符 
		①. ... 运算符
		②. 在函数定义时,可以将参数列表变成数组
		②. 在函数执行时可以讲数组拆分为参数列表,进行多参的函数执行
		<script type="text/javascript">
			function print(...arg){
				console.log(arg);
			}
			print(1,2,3,4,5,6); // [1,2,3,4,5,6]

			var arr = [1,2,3,4,5,6];
			print(...arr);		// [1,2,3,4,5,6]
		</script>

五.箭头函数
	<script type="text/javascript">
		// 无参
		var fun = () => num;
		var fun = function(){
			return num;
		}
		// 一参
		var fun = num => num;
		var fun = function(num){
			return num;
		}
		// 多参
		var fun = (x,y) => x+y;
		var fun = function(x,y){
			return x+y;
		}
		// 返回参数为对象时
		var fun = () => ({name:"xiaohui"})
	</script>
	箭头函数中的this,指向当前作用域的this(当前作用域的实例)
	<script type="text/javascript">
		var name =  "window"
		var Person = {
			name : "person",
			eat :function(){
				console.log(this.name);
			},
			xiaoming : {
				name : "xiaoming",
				drink : () => console.log(this.name),
				eat : function(){
					console.log(this.name);
				}
			}
		}
		Person.xiaoming.drink(); 	// window
		Person.xiaoming.eat();		// xiaoming
	</script>
	嵌套的箭头函数
	<script type="text/javascript">
		function fun(str){
			return function(){
				return str.split("");
			}
		}
		var fun = str => () => str.split("");
	</script>

六.数组的扩展
	1.扩展运算符
	<script type="text/javascript">
		var arr = [1,2,3,4,5];
		...arr === 1,2,3,4,5

			arr.push(1,2,3,4,5) 
		=== arr.push(...[1,2,3,4,5]) 
		=== arr.push.apply(arr,[1,2,3,4,5]) 
		=== Array.prototype.push.apply(arr,[1,2,3,4,5]);

		var arr1 = [1,2,3],arr2 = ["4","5","6"],arr3 = [true,false];
		// [1, 2, 3, "4", "5", "6", true, false]
		var arr2 = [...arr1,...arr2,...arr3];

		// x =1 y=[]
		var [x,...y] = [1];

		// x=1 y=[2,3,4,5]
		var [x,...y] = [1,2,3,4,5];

		// error : Rest element must be last element in array
		// 		   Rest(剩余部分) 元素必须是数组中的最后一个元素
		// var [x,...y,...z] = [1,2,3,4,5];
		 
		// arr = ['s','t','r','i','n','g']
		var arr = [..."string"]; 
	</script>
	2.Array.form() 把类数组转换为数组
	<script type="text/javascript">
		// ["s", "t", "r", "i", "n", "g"]
		var arr = Array.from("string");

		var arr_1 = {
			"0" : 1,
			"1" : 2,
			"2" : 3,
			length : 3
		}
		
		// arr = [1, 2, 3]
		var arr = Array.from(arr_1);

		// 第二个参数fnction
		// 处理类数组中的每一位,进行值返回.
		var arr = Array.from(arr_1,function(item,index){
			console.log(val);	
		});	

		// 参数传入一个数组,会返回一个 新的 内容一样的数组.
		Array.from(arr);
	</script>
	3.Array.of() 将一组数转换为数组
	<script type="text/javascript">
		var arr = new Array(5); 		// [,,,,]
		var arr = new Array(1,2,3);		// [1,2,3]
		
		var arr = Array.of(5);			// [5]
		var arr = new Array(1,2,3);		// [1,2,3]
		Array.prototype.of = function(){
			return Array.from(arguments);
		}
		Array.prototype.of = function(){
			return Array.prototype.slice.call(arguments);
		}
		Array.prototype.of = function(...arg){
			return arg;
		}
	</script>
	4.Array.prototype.copyWithin(target,start=0,end=this.length);
	// target 从那个坐标开始替换
	// start-end  要进行替换的值的 取值范围(取头不取尾,支持负数)
	<script type="text/javascript">
		var arr = [1,2,3,4,5];
		// 返回被改变后的原数组
		// [4, 5, 3, 4, 5]
		// 拿后面的值替换的前面的值,
		// 不写 end 参数默认拿到最后一位
		// [4, 5, 3, 4, 5] => [...[4,5],...[3,4,5]]
		var arr1 = arr.copyWithin(0,3);
	</script>
	5.Array.prototype.fill(val,start,end) 	填充
	val		要填充的值
	start	开始填充的位置
	end		结束填充的位置
	<script type="text/javascript">
		var arr = new Array(5);
		arr.fill("0");	// ["0","0","0","0","0"]
	</script>
	6.entries() keys() values()  遍历数组中的值
	<script type="text/javascript">
		var arr = ["1","2","3","4","5"];
		for(item of arr.entries() ){
			// [0, "1"]
			// [1, "2"]
			// [2, "3"]
			// [3, "4"]
			// [4, "5"]
			console.log(item)
		}
		for(item of arr.keys() ){
			// 0
			// 1
			// 2
			// 3
			// 4
			console.log(item)
		}
		for(item of arr.values() ){
			// "1"
			// "2"
			// "3"
			// "4"
			// "5"
			console.log(item)
		}
	</script>
	7.includes() find() findIndex()
	<script type="text/javascript">
		// item 返回第一个满足条件的参数
		var arr = [1,2,3,4,5];
		var val = arr.find(item => item>3);	// 4

		// item 返回第一个满足条件的参数在数组中的坐标
		// 找不到返回-1
		var arr = [1,2,3,4,5];
		var val = arr.findIndex(item => item>3); // 3

		// 查找数组中有没有我要查找的值,可以判断NaN
		// indexOf判断不了.
		var arr = [1,2,3,4,5];
		var val = arr.includes(2);
	</script>

七.对象的扩展
	1.属性的简洁表示法以及属性名表达式
	<script type="text/javascript">
		var name = "xiaohui";
		var obj = {name : name};
		// 属性的简洁表示法
		var obj = {name};
		
		var obj = {function demo(){
			console.log("demo");
		}};
		function demo(){
			console.log("demo");
		}
		var obj = {demo};

		// 属性名表达式,以变量作为属性名
		var name = "name_";
		var age  = "age_";
		// {name_: "xiaohui", age_: 18}
		var obj = {
			[name] : "xiaohui",
			[age] : 18,
		}
	</script>
	2.属性的可枚举性以及属性的遍历
	<script type="text/javascript">
		// for ... in
		// Object.keys

		var obj = {demo:"demo"};	
		// configurable:true 		
		// enumerable:true 			可枚举性(可不可以遍历出来)
		// value:"demo" 			当前对象,当前属性的值
		// writable:true 			是否可修改
		Object.getOwnPropertyDescriptor(obj,"demo");

		// Object.is() 在大多数情况下 与 === 相同
		Object.is(NaN,NaN);	// true
		Object.is(+0,-0);	// false

		// 将多个对象的可枚举属性放到一个对象中
		// 返回值为obj5 === obj
		// 修改原对象的值不会影响新对象的值(对象除外,浅copy).
		var obj = {};
		var obj1 = {a:{a:"a"}};
		var obj2 = {b:{b:"b"},bb:"bb"};
		var obj5 = Object.assign(obj,obj1,obj2,obj3,obj4); 
		obj1.a.a = "obj1";
		obj2.bb = "bbb";
		console.log(obj);
		console.log(obj1);
		console.log(obj2);

		// entries() keys() values()
		var obj = {a:"a",b:true,c:function(){}};
		var keys = Object.keys(obj);			// ["a", "b", "c"]
		var values = Object.values(obj);		// ["a", true, ƒ]
		var entries = Object.entries(obj);		// [["a", "a"],["b", true],["c", function]]


	</script>
	3.对象的扩展运算符
	<script type="text/javascript">
		// a=1 b=2 c={c: 3, d: 4} 
		var {a,b,...c} = {a:1,b:2,c:3,d:4};

		var a = {a:1,b:2},
			b = {c:3,d:4};
		var c = {...a,...b};	// {a: 1, b: 2, c: 3, d: 4}
	</script>|
八.Symbol(第七种数据类型)
	1.symbol 的值
	<script type="text/javascript">
		// Symbol()
		let str = Symbol();
		// Symbol(1)
		let str1 = Symbol('1');
		
		// Symbol(2)
		// 传入对象自动调用toString方法
		let str2 = Symbol({toString(){
			return '2'
		}});
		// 当没有指定
		// Symbol([object Object])
		let str2 = Symbol({});
		
		// 相同参数的Symbol不相等
		let a = Symbol('1'),b = Symbol('1');
		// false
		a === b;
	</script>
	2.symbol 的转换
	<script type="text/javascript">
		// Symbol 值不能与其他类型的值进行运算，会报错。
		let sym = Symbol('My symbol');
		"your symbol is " + sym
		// TypeError: can't convert symbol to string
		`your symbol is ${sym}`
		// TypeError: can't convert symbol to string
		
		// Symbol 值可以显式转为字符串。
		let sym = Symbol('My symbol');
		String(sym) // 'Symbol(My symbol)'
		sym.toString() // 'Symbol(My symbol)'

		// 另外，Symbol 值也可以转为布尔值，但是不能转为数值。
		let sym = Symbol();
		Boolean(sym) // true
		!sym  // false

		if (sym) {
		  // ...
		}

		Number(sym) // TypeError
		sym + 2 // TypeError
	</script>
	3.作为属性名的Symbol
	<script type="text/javascript">
		let symbolA = Symbol('a'),
			symbolB = Symbol('a');
		
		// symbolA: "symbolA_false"
		// Symbol(a): "symbolA_true"
		// Symbol(a): "symbolB_true"
		let obj = {
			symbolA: 'symbolA_false',
			[symbolA]: 'symbolA_true',
			[symbolB]: 'symbolB_true',
		}

		// "symbolA_false"
		obj.symbolA;
		// "symbolA_true"
		obj[symbolA];
		// "symbolB_true"
		obj[symbolB];

		// Symbol 作为属性名，该属性不会出现在for...in、for...of循环中
		// for...in、for...of 也遍历不出 key 为 Symbol 的属性及值
		// ["symbolA"]
		Object.keys(obj);
		// ["symbolA"]
		Object.getOwnPropertyNames(obj);
		// "{"symbolA":"symbolA_false"}"
		JSON.stringify(obj);


		// 获取对象中Symbol属性名的 集合/数组
		// [Symbol(a), Symbol(a)]
		Object.getOwnPropertySymbols(obj);

		// Reflect.ownKeys 返回所有类型的键名(返回所有类型的键名)
		// ["symbolA", Symbol(a), Symbol(a)]
		Reflect.ownKeys(obj);
	</script>
	4.Symbol.for(), Symbol.keyFor(), Symbol.keyFor();
	<script type="text/javascript">
		// Symbol.for() 获取已经创建的Symbol.for()
		// 当不存在时新建一个,存在时获取以创建的
		// Symbol.for() 会在全局进行登记操作 (可以在不同的 iframe 或 service worker 中取到同一个值);
		let a = Symbol('foo');
		let b = Symbol.for('foo');
		let c = Symbol.for('foo');
		a === b; // false
		b === c; // true

		// Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key,没有则返回undefined
		Symbol.keyFor(a);	// undefined
		Symbol.keyFor(b);	// foo
	</script>
	5.Symbol.hasInstance
	<script type="text/javascript">
		// 当Symbol.hasInstance 为对象的一个属性值时
		// 这个属性值对应的函数会重写当前属性对应对象的 instanceof 指令
		class Even {
		  static [Symbol.hasInstance](obj) {
		    return Number(obj) % 2 === 0;
		  }
		}
		// 等同于
		const Even = {
		  [Symbol.hasInstance](obj) {
		    return Number(obj) % 2 === 0;
		  }
		};

		1 instanceof Even; 		// false
		2 instanceof Even; 		// true
		12345 instanceof Even; 	// false
	</script>
	6.Symbol.isConcatSpreadable
	<script type="text/javascript">
		// 定义当前 对象/数组 作为concat的参数时,是否可展开.
		// 数组
		let arr1 = ['c', 'd'];
		['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
		arr1[Symbol.isConcatSpreadable] // undefined

		let arr2 = ['c', 'd'];
		arr2[Symbol.isConcatSpreadable] = false;
		['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']

		// 对象
		let obj = {length: 2, 0: 'c', 1: 'd'};
		['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

		obj[Symbol.isConcatSpreadable] = true;
		['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
	</script>
	7.Symbol.species
	<script type="text/javascript">
		// 重写衍生对象的 instanceof/自身构造函数 的指向
		// Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数
		class MyArray extends Array {
		}
		const a = new MyArray(1, 2, 3);
		const b = a.map(x => x);
		const c = a.filter(x => x > 1);

		a instanceof MyArray; // true
		b instanceof MyArray; // true
		c instanceof MyArray; // true

		class ItArray extends Array {
		  static get [Symbol.species]() { return Array; }
		}
		const e = new ItArray(1, 2, 3);
		const f = e.map(x => x);
		const g = e.filter(x => x > 1);

		e instanceof ItArray; // true
		f instanceof ItArray;	// false
		g instanceof ItArray;	// false
	</script>
	8.Symbol.match
	<script type="text/javascript">
		// 当前对象作为match的函数的参数时 重写match函数
		

		String.prototype.match(regexp);
		// 等同于
		regexp[Symbol.match](this);

		// RegExp 中拥有 Symbol.match 函数的的实现
		// /a/g[Symbol.match]('abc') 调用 /a/g 的 Symbol.match 函数
		'abc'.match(/a/g) === /a/g[Symbol.match]('abc');

		class MyMatcher {
		  [Symbol.match](string) {
		    return 'hello world'.indexOf(string);
		  }
		}

		'e'.match(new MyMatcher()) // 1
	</script>
	9.Symbol.replace
	<script type="text/javascript">
		// 指向一个方法，当该对象被 String.prototype.replace 方法调用时，会返回该方法的返回值
		// 重写replace函数
		String.prototype.replace(searchValue, replaceValue);
		// 等同于
		searchValue[Symbol.replace](this, replaceValue);

		const x = {
			[Symbol.replace](...s){
				console.log(s);
			}
		};
		'Hello'.replace(x, 'World') // ["Hello", "World"]
	</script>
	10.Symbol.search
	<script type="text/javascript">
		// 当该对象被String.prototype.search方法调用时，会返回该方法的返回值
		// 重写search函数
		String.prototype.search(regexp)
		// 等同于
		regexp[Symbol.search](this)

		class MySearch {
		  constructor(value) {
		    this.value = value;
		  }
		  [Symbol.search](string) {
		    return string.indexOf(this.value);
		  }
		}
		'foobar'.search(new MySearch('foo')) // 0
	</script>
	11.Symbol.split
	<script type="text/javascript">
		// 重写split函数
		String.prototype.split(separator, limit)
		// 等同于
		separator[Symbol.split](this, limit)
		class MySplitter {
		  constructor(value) {
		    this.value = value;
		  }
		  [Symbol.split](string) {
		    let index = string.indexOf(this.value);
		    if (index === -1) {
		      return string;
		    }
		    return [
		      string.substr(0, index),
		      string.substr(index + this.value.length)
		    ];
		  }
		}

		'foobar'.split(new MySplitter('foo'))
		// ['', 'bar']

		'foobar'.split(new MySplitter('bar'))
		// ['foo', '']

		'foobar'.split(new MySplitter('baz'))
		// 'foobar'
	</script>
	12.Symbol.iterator
	<script type="text/javascript">
		// 重写默认遍历器方法( for...of )
		const myIterable = {};
		myIterable[Symbol.iterator] = function* () {
		  yield 1;
		  yield 2;
		  yield 3;
		};

		[...myIterable] // [1, 2, 3]
		class Collection {
		  *[Symbol.iterator]() {
		    let i = 0;
		    while(this[i] !== undefined) {
		      yield this[i];
		      ++i;
		    }
		  }
		}

		let myCollection = new Collection();
		myCollection[0] = 1;
		myCollection[1] = 2;

		for(let value of myCollection) {
		  console.log(value);
		}
		// 1
		// 2
	</script>
	13.Symbol.toPrimitive
	<script type="text/javascript">
		// 数据类型转换函数重写,返回自定义函数的返回值
		// 拥有三种情况 number string 和 default
		// 没有 隐式/强制 类型转换时值为default.
		// hint === string 隐式类型转换得不到,只能通过强转(目前)
		let obj = {
		  [Symbol.toPrimitive](hint) {
		    switch (hint) {
		      case 'number':
		        return 123;
		      case 'string':
		        return 'str';
		      case 'default':
		        return 'default';
		      default:
		        throw new Error();
		     }
		   }
		};

		1 + a;			// "1default"
		2 * a;			// 246
		'3' * a;		// 369
		'4' + a;		// "4default"
		String(a); 	// "str"
	</script>
	14.Symbol.toStringTag
	<script type="text/javascript">
		//  重写 对象的toString函数
		//  实际和 Object.prototype.toString 类型判断返回值 关系不大
		// 例一
		({[Symbol.toStringTag]: 'Foo'}.toString())
		// "[object Foo]"

		// 例二
		class Collection {
		  get [Symbol.toStringTag]() {
		    return 'xxx';
		  }
		}
		let x = new Collection();
		Object.prototype.toString.call(x) // "[object xxx]"

		// ES6 新增内置对象的Symbol.toStringTag属性值如下。
		/*
		JSON[Symbol.toStringTag]：'JSON'
		Math[Symbol.toStringTag]：'Math'
		Module 对象M[Symbol.toStringTag]：'Module'
		ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'
		DataView.prototype[Symbol.toStringTag]：'DataView'
		Map.prototype[Symbol.toStringTag]：'Map'
		Promise.prototype[Symbol.toStringTag]：'Promise'
		Set.prototype[Symbol.toStringTag]：'Set'
		%TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等
		WeakMap.prototype[Symbol.toStringTag]：'WeakMap'
		WeakSet.prototype[Symbol.toStringTag]：'WeakSet'
		%MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'
		%SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'
		%StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'
		Symbol.prototype[Symbol.toStringTag]：'Symbol'
		Generator.prototype[Symbol.toStringTag]：'Generator'
		GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'
		*/
	</script>
	15.Symbol.unscopables
	<script type="text/javascript">
		// 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。
		// 以对象的形式配置在函数的返回值中
		// 没有 unscopables 时
		class MyClass {
		  foo() { return 1; }
		}

		var foo = function () { return 2; };

		with (MyClass.prototype) {
		  foo(); // 1
		}

		// 有 unscopables 时
		class MyClass {
		  foo() { return 1; }
		  get [Symbol.unscopables]() {
		    return { foo: true };	// {'foo': true}
		  }
		}

		var foo = function () { return 2; };

		with (MyClass.prototype) {
		  foo(); // 2
		}

		// {"copyWithin":true,"entries":true,"fill":true,"find":true,"findIndex":true,"includes":true,"keys":true,"values":true}
		// 数组有 7 个属性，会被with命令排除。
		Array.prototype[Symbol.unscopables];
	</script>
九.Set 和 Map 数据结构
	1.Set
	// 初始化
	<script type="text/javascript">
		// Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
		// 例一
		const set = new Set([1, 2, 3, 4, 4]);
		[...set]		// [1, 2, 3, 4]

		// 例二
		const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
		items.size 	// 5

		// 例三
		const set = new Set(document.querySelectorAll('div'));
		set.size 		// 56
	</script> 
	// add
	<script type="text/javascript">
		const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
		s;	// Set(4) {2, 3, 5, 4}
	</script>
	// 去重
	<script type="text/javascript">
		// 去除数组的重复成员
		[...new Set([1,2,3,4,1,2,3,2])]
		// 去除重复字符串
		[...new Set('ababbc')].join('')	
	</script>
	// Set 属性/函数
	// Array.from方法可以将 Set 结构转为数组。
	<script type="text/javascript">
		let s = new Set();
		// 属性
		Set.prototype.constructor; 	// 构造函数，默认就是Set函数
		Set.prototype.size;					// 返回Set实例的成员总数。

		// 函数
		// 操作函数
		s.add('1');			// 添加某个值，返回 Set 结构本身。
		s.delete('1');	// 删除某个值，返回一个布尔值，表示删除是否成功。
		s.has('1');			// 返回一个布尔值，表示该值是否为Set的成员。
		s.clear();			// 清除所有成员，没有返回值。


		s.size 									// 2
		s.add(1).add(2).add(2);	// 注意2被加入了两次

		s.has(1); 		// true
		s.has(2); 		// true
		s.has(3); 		// false
		s.delete(2);	// true
		s.has(2); 		// false
		s.delete(2);	// false

		// 遍历函数
		s.keys();			// 返回键名的遍历器
		s.values();		// 返回键值的遍历器
		s.entries();	// 返回键值对的遍历器
		s.forEach();	// 使用回调函数遍历每个成员
		// 由于 Set 结构没有键名，只有键值
		let set = new Set(['red', 'green', 'blue']);
		for (let item of set.keys()) console.log(item);	// red green blue
		for (let item of set.keys()) console.log(item);	// red green blue
		for (let item of set.keys()) console.log(item);	// ["red", "red"] ["green", "green"] ["blue", "blue"]

		// Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
		Set.prototype[Symbol.iterator] === Set.prototype.values; 	// true
		for (let x of set) console.log(x);	// red green blue
		// Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。
		// forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。
		set.forEach((value, key) => console.log(key + ':' + value)); // red:red green:green blue:blue
	</script>
	Set的应用
	// 扩展运算符（...）内部使用for...of循环.
	<script type="text/javascript">
		// 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。
		let unique = [...new Set([3, 5, 2, 2, 5, 5])];	// [3, 5, 2]
		// 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
		let a = new Set([1, 2, 3]);
		let b = new Set([4, 3, 2]);

		// 并集
		let union = new Set([...a, ...b]);												// Set {1, 2, 3, 4}
		// 交集
		let intersect = new Set([...a].filter(x => b.has(x)));		// set {2, 3}
		// 差集
		let difference = new Set([...a].filter(x => !b.has(x)));	// Set {1}

		// 在遍历操作中改变原来的 Set 结构。
		// 方法一
		let set = new Set([1, 2, 3]);
		set = new Set([...set].map(val => val * 2));
		// set的值是2, 4, 6

		// 方法二
		let set = new Set([1, 2, 3]);
		set = new Set(Array.from(set, val => val * 2));
		// set的值是2, 4, 6
	</script>
	2.WeakSet
	// 初始化/定义
	<script type="text/javascript">
		// WeakSet 结构与 Set 类似
		// WeakSet 的成员只能是对象，而不能是其他类型的值
		// WeakSet 中的对象都是弱引用(垃圾回收机制不考虑 WeakSet 对该对象的引用,
		// 如果其他对象都不再引用该对象，也就是说,如果其他对象都不再引用该对象，
		// 那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。)
		// ES6 规定 WeakSet 不可遍历
		
		// 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数
		// 注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。
		const a = [[1, 2], [3, 4]];
		const wsa = new WeakSet(a); // WeakSet {[1, 2], [3, 4]}
		
		const b = [3, 4];
		const wsb = new WeakSet(b);	// Uncaught TypeError: Invalid value used in weak set(…)
	</script>
	// 函数
	<script type="text/javascript">
		WeakSet.prototype.add(value);				// 向 WeakSet 实例添加一个新成员。
		WeakSet.prototype.delete(value);		// 清除 WeakSet 实例的指定成员。
		WeakSet.prototype.has(value);				// 返回一个布尔值，表示某个值是否在 

		const ws = new WeakSet();
		const obj = {};
		const foo = {};

		ws.add(window);
		ws.add(obj);

		ws.has(window); 		// true
		ws.has(foo);    		// false

		ws.delete(window);
		ws.has(window);    	// false
	</script>
	// 作用
	<script type="text/javascript">
		// WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
		const foos = new WeakSet()
		class Foo {
		  constructor() {
		    foos.add(this)
		  }
		  method () {
		    if (!foos.has(this)) {
		      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
		    }
		  }
		}
	</script>
	3.Map
	// 初始化
	<script type="text/javascript">
		// Map 数据结构。类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
		const m = new Map();
		const o = {p: 'Hello World'};
		m.set(o, 'content')
		m.get(o) // "content"
		m.has(o) // true
		m.delete(o) // true
		m.has(o) // false
		// 数组作为参数实例化
		const map = new Map([
		  ['name', '张三'],
		  ['title', 'Author']
		]);
		map.size // 2
		map.has('name') // true
		map.get('name') // "张三"
		map.has('title') // true
		map.get('title') // "Author"
		// Map构造函数接受数组作为参数，实际上执行的是下面的算法。
		const items = [
		  ['name', '张三'],
		  ['title', 'Author']
		];
		const map = new Map();
		items.forEach(
		  ([key, value]) => map.set(key, value)
		);
		// 如果对同一个键多次赋值，后面的值将覆盖前面的值。
		const map = new Map();
		map
		.set(1, 'aaa')
		.set(1, 'bbb');
		map.get(1) // "bbb"
		// 如果读取一个未知的键，则返回undefined
		new Map().get('asfddfsasadf') // undefined
		// 只有对同一个对象的引用，Map 结构才将其视为同一个键
		const map = new Map();
		map.set(['a'], 555);
		map.get(['a']) // undefined

		// 原始值的初始化
		let map = new Map();
		map.set(-0, 123);
		map.get(+0) // 123
		map.set(true, 1);
		map.set('true', 2);
		map.get(true) // 1
		map.set(undefined, 3);
		map.set(null, 4);
		map.get(undefined) // 3
		map.set(NaN, 123);
		map.get(NaN) // 123
	</script>
	// 属性/函数
	<script type="text/javascript">
		// size属性返回 Map 结构的成员总数。
		// set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。
		// get方法读取key对应的键值，如果找不到key，返回undefined。
		// has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
		// delete方法删除某个键，返回true。如果删除失败，返回false。
		// clear方法清除所有成员，没有返回值。
		
		keys();			// 返回键名的遍历器。
		values();		// 返回键值的遍历器。
		entries();	// 返回所有成员的遍历器。
		forEach();	// 遍历 Map 的所有成员。
		const map = new Map([
		  ['F', 'no'],
		  ['T',  'yes'],
		]);

		for (let key of map.keys()) console.log(key);											// "F" "T"
		for (let value of map.values())  console.log(value); 							// "no" "yes"
		for (let item of map.entries()) console.log(item[0], item[1]);		// "F" "no"		"T" "yes"
		for (let [key, value] of map.entries())  console.log(key, value);	// "F" "no"		"T" "yes"
		// 等同于使用map.entries()
		for (let [key, value] of map) console.log(key, value);						// "F" "no"		"T" "yes"
	</script>
	// map的使用
	<script type="text/javascript">
		// 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。
		const map0 = new Map()
		  .set(1, 'a')
		  .set(2, 'b')
		  .set(3, 'c');
		const map1 = new Map(
		  [...map0].filter(([k, v]) => k < 3)
		);

		// 产生 Map 结构 {1 => 'a', 2 => 'b'}
		const map2 = new Map(
		  [...map0].map(([k, v]) => [k * 2, '_' + v])
		);

		// Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。
		map.forEach(function(value, key, map) {
		  console.log("Key: %s, Value: %s", key, value);
		});

		// forEach方法还可以接受第二个参数，用来绑定this
		const reporter = {
		  report: function(key, value) {
				console.log("Key: %s, Value: %s", key, value);
			}
		};

		map.forEach(function(value, key, map) {
		  this.report(key, value);
		}, reporter);
	</script>
	4.WeakMap
	// 初始化
	<script type="text/javascript">
		// WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
		const map = new WeakMap();
		map.set(1, 2)
		// TypeError: 1 is not an object!
		map.set(Symbol(), 2)
		// TypeError: Invalid value used as weak map key
		map.set(null, 2)
		// TypeError: Invalid value used as weak map key
	</script>
	// 语法
	<script type="text/javascript">
		// 只有四个方法可用：get()、set()、has()、delete()。
	</script>
