<meta charset="utf-8">
<title>ES6</title>
一.块级作用域(let/const)
	1.不存在变量提升
	2.暂时性死区(在声明之前不可以使用)
	3.不允许重复声明
	4.let
	<script type="text/javascript">
		var arr = []
		for (let i = 0; i < 3; i++) {
			arr[i] = function () { console.log(i) }
		}
		arr[0]();
		// 个人理解for,let的解析.
		let i = 0;
		if(i < 3){
			arr[i] = function () { console.log(i) }	
		}
		i++;
		if(i < 3){
			arr[i] = function () { console.log(i) }	
		}
		i++;
		// 由于let i是块级作用域所以当for循环后
		// {}内的i 都是独立存在的.
	</script>
	5.const : 常量
		1.由const定义的为常量,不可更改
		2.由const定义的为常量为对象是.修改对象的内容是可以的.

二.变量的结构赋值(实质:模式匹配)
	1.数组的结构赋值(有序)
	<script type="text/javascript">
		var [a,b,c] = [1,2,3];
		let [d,e,f] = [1,2,3];
		// 结构不成功
		let [g,h,i] = [1,2];
		// 不完全结构
		let [j,k] = [1,2,3];
		// 默认值
		let [l = 1,m = 2] = [];
	</script>
	2.对象的结构赋值(无序),实际只是以对象的模式,进行模式匹配赋值而已.
	<script type="text/javascript">
		//***** a代表模式. b代表变量 *****//
		let {a,b} = {a:1,b:2};
		
		let {a:a,b:b} = {a:1,b:2}; // a=1,b=2
		let {a:b,b:a} = {a:1,b:2}; // a=2,b=1
		
		// 默认值
		let {a=1,b=1} = {};
		let {a:a=1,b:b=1} = {};
		
		// 对象的多次解构
		var obj = {
			person : {
				name : "xiaohui",
				like : ["eat",{"fulit":["banana","orange"]}]
			}
		}
		var {person:{name,like:[eat,{fulit:[a,b]}]}} = obj;
		var {person,person:{name,like,like:[eat,{fulit,fulit:[a,b]}]}} = obj;
		var {person:person,person:{name:name,like:like,like:[eat:eat,{fulit:fulit,fulit:[a:a,b:b]}]}} = obj;
	</script>
	3.默认值
		①.当进行结构赋值时,先进行模式匹配进行赋值,假如模式匹配失败,再取默认值.
		②.当模式匹配赋值绝对等于undefined(===undefined)时,取默认值.
	4.默认结构
	<script type="text/javascript">
		// 执行时,先把string解析为对象(浏览器内核自动完成的).
		var {length} = "length"; 		// length=6
		// 执行时,先把字符串解析为数组(浏览器内核自动完成的).
		var [a,b,c,d,e,f] = "123456"; 	// a=1,b=2,c=3,d=4,e=5,f=6
		var arr = [[1,2],[3,4],[5,6],[7,8]];
		// 令函数在赋值执行时,以结构的方式对形参进行赋值.
		function add([a,b]){
			console.log(a,b);
		}
		add([1,2]);

		arr.forEach(function([a,b]){
			console.log(a,b);	//  1,2  3,4  5,6  7,8  	
		})

		var {toString:num} = 1;
		var {toString:str} = "1";
		var {toString:arr} = [];
		var {toString:fun} = function(){};
		var a=	num === Number.prototype.toString;
		var	b=	str === String.prototype.toString;
		var	c=	arr === Array.prototype.toString;
		var	d=	fun === Function.prototype.toString;
	</script>

三.字符串的扩展
	1.模板字符串( `` )
		①.增强的字符串
		<script type="text/javascript">
			var div = `
				<div class="">
					<a href="javascript:0" class=""></a>
				</div>`
		</script>
		②.在字符串中添加变量或者表达式
		<script type="text/javascript">
			var user = {
				name:"xiaoming",
				age:18,
				like:"fulit",
			}
			var str = `name : ${user['name']} ,age : ${user['age']} ,like : ${user['like']}`;
			console.log(str);

			// 调用函数
			function get_name(){
				return "xiao hui"
			}
			console.log(`my name is ${get_name()}`);

			// 模板字符串嵌套
			var arr = [1,2,3,4,5];
			var str = `${arr.map(function(item,index){
				return `${index} : ${item}`
			})}`
			console.log(str);
		</script>
	
	2.标签模板
		①.标签模板实质——函数调用的特殊形式
		<script type="text/javascript">
			alert`呵呵`;

			name = "xiao hui";
			area = "Bei Jing";
			function test(name){
				console.log(name);	
				return name;
			}
			// ["", "", raw: Array[2]]
			test`${name}`;	

			// [" hello ", " ,welcome to ", "", raw: Array[3]]
			test` hello ${name} ,welcome to ${area}`;		
		</script>
		②.重要应用——过滤HTML字符串
		<script type="text/javascript">
				var demo = '<script>console.log("ok")<\/script>';

				filterHtml`<p> ${demo} </p>`;

				function filterHtml(arr){
					var str = arr[0],
						len = arguments.length;
					for(var i= 1;i<len;i++){
						str +=  arguments[i].replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
						str +=  arr[i];
					}
					return str; // "<p> &lt;script&gt;console.log("ok")&lt;/script&gt; </p>"
				}
		</script>

四.函数的扩展
	1.函数参数的默认值
		①.基本使用
		<script type="text/javascript">
			function demo(x,y=100){
				console.log(x,y);
			}
			demo(10);	// 10 100
		</script>
		②.结构赋值结合使用
		<script type="text/javascript">
			function demo({x,y=5}){
				console.log(x,y);
			}
			// demo()
			// error : 不能分解"未定义"或"null"的属性`x`
			// 也就是说在执行x值的结构时结构失败的error;
			// 与 var {x,y} = null error 相同
			demo({});			// undefined 5
			demo({x:1});		// 1 5
			demo({y:2});		// undefined 2
			demo({x:3,y:4});	// 3 4

			function f1({x=0,y=0} = {}){ 
				console.log(x,y);
			}
			f1();			// 0 0
			f1({});			// 0 0
			f1({x:1});		// 1 0
			f1({y:2});		// 0 2
			f1({x:3,y:4});	// 3 4

			function f2({x,y} = {x:0,y:0}){
				console.log(x,y);
			}
			f2();			// 0 0
			f2({});			// undefined undefined
			f2({x:1});		// 1 undefined
			f2({y:2});		// undefined 2
			f2({x:3,y:4});	// 3 4		
		</script>
	2.参数作用域以及注意事项
		<script type="text/javascript">
			let x =5;	
			function(){ 
				let x = 10;
			}
		</script>
	3.扩展运算符 
		①. ... 运算符
		②. 在函数定义时,可以将参数列表变成数组
		②. 在函数执行时可以讲数组拆分为参数列表,进行多参的函数执行
		<script type="text/javascript">
			function print(...arg){
				console.log(arg);
			}
			print(1,2,3,4,5,6); // [1,2,3,4,5,6]

			var arr = [1,2,3,4,5,6];
			print(...arr);		// [1,2,3,4,5,6]
		</script>

五.箭头函数
	<script type="text/javascript">
		// 无参
		var fun = () => num;
		var fun = function(){
			return num;
		}
		// 一参
		var fun = num => num;
		var fun = function(num){
			return num;
		}
		// 多参
		var fun = (x,y) => x+y;
		var fun = function(x,y){
			return x+y;
		}
		// 返回参数为对象时
		var fun = () => ({name:"xiaohui"})
	</script>
	箭头函数中的this,指向当前作用域的this(当前作用域的实例)
	<script type="text/javascript">
		var name =  "window"
		var Person = {
			name : "person",
			eat :function(){
				console.log(this.name);
			},
			xiaoming : {
				name : "xiaoming",
				drink : () => console.log(this.name),
				eat : function(){
					console.log(this.name);
				}
			}
		}
		Person.xiaoming.drink(); 	// window
		Person.xiaoming.eat();		// xiaoming
	</script>
	嵌套的箭头函数
	<script type="text/javascript">
		function fun(str){
			return function(){
				return str.split("");
			}
		}
		var fun = str => () => str.split("");
	</script>

六.数组的扩展
	1.扩展运算符
	<script type="text/javascript">
		var arr = [1,2,3,4,5];
		...arr === 1,2,3,4,5

			arr.push(1,2,3,4,5) 
		=== arr.push(...[1,2,3,4,5]) 
		=== arr.push.apply(arr,[1,2,3,4,5]) 
		=== Array.prototype.push.apply(arr,[1,2,3,4,5]);

		var arr1 = [1,2,3],arr2 = ["4","5","6"],arr3 = [true,false];
		// [1, 2, 3, "4", "5", "6", true, false]
		var arr2 = [...arr1,...arr2,...arr3];

		// x =1 y=[]
		var [x,...y] = [1];

		// x=1 y=[2,3,4,5]
		var [x,...y] = [1,2,3,4,5];

		// error : Rest element must be last element in array
		// 		   Rest(剩余部分) 元素必须是数组中的最后一个元素
		// var [x,...y,...z] = [1,2,3,4,5];
		 
		// arr = ['s','t','r','i','n','g']
		var arr = [..."string"]; 
	</script>
	2.Array.form() 把类数组转换为数组
	<script type="text/javascript">
		// ["s", "t", "r", "i", "n", "g"]
		var arr = Array.from("string");

		var arr_1 = {
			"0" : 1,
			"1" : 2,
			"2" : 3,
			length : 3
		}
		
		// arr = [1, 2, 3]
		var arr = Array.from(arr_1);

		// 第二个参数fnction
		// 处理类数组中的每一位,进行值返回.
		var arr = Array.from(arr_1,function(item,index){
			console.log(val);	
		});	

		// 参数传入一个数组,会返回一个 新的 内容一样的数组.
		Array.from(arr);
	</script>
	3.Array.of() 将一组数转换为数组
	<script type="text/javascript">
		var arr = new Array(5); 		// [,,,,]
		var arr = new Array(1,2,3);		// [1,2,3]
		
		var arr = Array.of(5);			// [5]
		var arr = new Array(1,2,3);		// [1,2,3]
		Array.prototype.of = function(){
			return Array.from(arguments);
		}
		Array.prototype.of = function(){
			return Array.prototype.slice.call(arguments);
		}
		Array.prototype.of = function(...arg){
			return arg;
		}
	</script>
	4.Array.prototype.copyWithin(target,start=0,end=this.length);
	// target 从那个坐标开始替换
	// start-end  要进行替换的值的 取值范围(取头不取尾,支持负数)
	<script type="text/javascript">
		var arr = [1,2,3,4,5];
		// 返回被改变后的原数组
		// [4, 5, 3, 4, 5]
		// 拿后面的值替换的前面的值,
		// 不写 end 参数默认拿到最后一位
		// [4, 5, 3, 4, 5] => [...[4,5],...[3,4,5]]
		var arr1 = arr.copyWithin(0,3);
	</script>
	5.Array.prototype.fill(val,start,end) 	填充
	val		要填充的值
	start	开始填充的位置
	end		结束填充的位置
	<script type="text/javascript">
		var arr = new Array(5);
		arr.fill("0");	// ["0","0","0","0","0"]
	</script>
	6.entries() keys() values()  遍历数组中的值
	<script type="text/javascript">
		var arr = ["1","2","3","4","5"];
		for(item of arr.entries() ){
			// [0, "1"]
			// [1, "2"]
			// [2, "3"]
			// [3, "4"]
			// [4, "5"]
			console.log(item)
		}
		for(item of arr.keys() ){
			// 0
			// 1
			// 2
			// 3
			// 4
			console.log(item)
		}
		for(item of arr.values() ){
			// "1"
			// "2"
			// "3"
			// "4"
			// "5"
			console.log(item)
		}
	</script>
	7.includes() find() findIndex()
	<script type="text/javascript">
		// item 返回第一个满足条件的参数
		var arr = [1,2,3,4,5];
		var val = arr.find(item => item>3);	// 4

		// item 返回第一个满足条件的参数在数组中的坐标
		// 找不到返回-1
		var arr = [1,2,3,4,5];
		var val = arr.findIndex(item => item>3); // 3

		// 查找数组中有没有我要查找的值,可以判断NaN
		// indexOf判断不了.
		var arr = [1,2,3,4,5];
		var val = arr.includes(2);
	</script>

七.对象的扩展
	1.属性的简洁表示法以及属性名表达式
	<script type="text/javascript">
		var name = "xiaohui";
		var obj = {name : name};
		// 属性的简洁表示法
		var obj = {name};
		
		var obj = {function demo(){
			console.log("demo");
		}};
		function demo(){
			console.log("demo");
		}
		var obj = {demo};

		// 属性名表达式,以变量作为属性名
		var name = "name_";
		var age  = "age_";
		// {name_: "xiaohui", age_: 18}
		var obj = {
			[name] : "xiaohui",
			[age] : 18,
		}
	</script>
	2.属性的可枚举性以及属性的遍历
	<script type="text/javascript">
		// for ... in
		// Object.keys

		var obj = {demo:"demo"};	
		// configurable:true 		
		// enumerable:true 			可枚举性(可不可以遍历出来)
		// value:"demo" 			当前对象,当前属性的值
		// writable:true 			是否可修改
		Object.getOwnPropertyDescriptor(obj,"demo");

		// Object.is() 在大多数情况下 与 === 相同
		Object.is(NaN,NaN);	// true
		Object.is(+0,-0);	// false

		// 将多个对象的可枚举属性放到一个对象中
		// 返回值为obj5 === obj
		// 修改原对象的值不会影响新对象的值(对象除外,浅copy).
		var obj = {};
		var obj1 = {a:{a:"a"}};
		var obj2 = {b:{b:"b"},bb:"bb"};
		var obj5 = Object.assign(obj,obj1,obj2,obj3,obj4); 
		obj1.a.a = "obj1";
		obj2.bb = "bbb";
		console.log(obj);
		console.log(obj1);
		console.log(obj2);

		// entries() keys() values()
		var obj = {a:"a",b:true,c:function(){}};
		var keys = Object.keys(obj);			// ["a", "b", "c"]
		var values = Object.values(obj);		// ["a", true, ƒ]
		var entries = Object.entries(obj);		// [["a", "a"],["b", true],["c", function]]


	</script>
	3.对象的扩展运算符
	<script type="text/javascript">
		// a=1 b=2 c={c: 3, d: 4} 
		var {a,b,...c} = {a:1,b:2,c:3,d:4};

		var a = {a:1,b:2},
			b = {c:3,d:4};
		var c = {...a,...b};	// {a: 1, b: 2, c: 3, d: 4}
	</script>|

八.Symbol(第七种数据类型)
	1.symbol 的值
	<script type="text/javascript">
		// Symbol()
		let str = Symbol();
		// Symbol(1)
		let str1 = Symbol('1');
		
		// Symbol(2)
		// 传入对象自动调用toString方法
		let str2 = Symbol({toString(){
			return '2'
		}});
		// 当没有指定
		// Symbol([object Object])
		let str2 = Symbol({});
		
		// 相同参数的Symbol不相等
		let a = Symbol('1'),b = Symbol('1');
		// false
		a === b;
	</script>
	2.symbol 的转换
	<script type="text/javascript">
		// Symbol 值不能与其他类型的值进行运算，会报错。
		let sym = Symbol('My symbol');
		"your symbol is " + sym
		// TypeError: can't convert symbol to string
		`your symbol is ${sym}`
		// TypeError: can't convert symbol to string
		
		// Symbol 值可以显式转为字符串。
		let sym = Symbol('My symbol');
		String(sym) // 'Symbol(My symbol)'
		sym.toString() // 'Symbol(My symbol)'

		// 另外，Symbol 值也可以转为布尔值，但是不能转为数值。
		let sym = Symbol();
		Boolean(sym) // true
		!sym  // false

		if (sym) {
		  // ...
		}

		Number(sym) // TypeError
		sym + 2 // TypeError
	</script>
	3.作为属性名的Symbol
	<script type="text/javascript">
		let symbolA = Symbol('a'),
			symbolB = Symbol('a');
		
		// symbolA: "symbolA_false"
		// Symbol(a): "symbolA_true"
		// Symbol(a): "symbolB_true"
		let obj = {
			symbolA: 'symbolA_false',
			[symbolA]: 'symbolA_true',
			[symbolB]: 'symbolB_true',
		}

		// "symbolA_false"
		obj.symbolA;
		// "symbolA_true"
		obj[symbolA];
		// "symbolB_true"
		obj[symbolB];

		// Symbol 作为属性名，该属性不会出现在for...in、for...of循环中
		// for...in、for...of 也遍历不出 key 为 Symbol 的属性及值
		// ["symbolA"]
		Object.keys(obj);
		// ["symbolA"]
		Object.getOwnPropertyNames(obj);
		// "{"symbolA":"symbolA_false"}"
		JSON.stringify(obj);


		// 获取对象中Symbol属性名的 集合/数组
		// [Symbol(a), Symbol(a)]
		Object.getOwnPropertySymbols(obj);

		// Reflect.ownKeys 返回所有类型的键名(返回所有类型的键名)
		// ["symbolA", Symbol(a), Symbol(a)]
		Reflect.ownKeys(obj);
	</script>
	4.Symbol.for(), Symbol.keyFor(), Symbol.keyFor();
	<script type="text/javascript">
		// Symbol.for() 获取已经创建的Symbol.for()
		// 当不存在时新建一个,存在时获取以创建的
		// Symbol.for() 会在全局进行登记操作 (可以在不同的 iframe 或 service worker 中取到同一个值);
		let a = Symbol('foo');
		let b = Symbol.for('foo');
		let c = Symbol.for('foo');
		a === b; // false
		b === c; // true

		// Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key,没有则返回undefined
		Symbol.keyFor(a);	// undefined
		Symbol.keyFor(b);	// foo
	</script>
	5.Symbol.hasInstance
	<script type="text/javascript">
		// 当Symbol.hasInstance 为对象的一个属性值时
		// 这个属性值对应的函数会重写当前属性对应对象的 instanceof 指令
		class Even {
		  static [Symbol.hasInstance](obj) {
		    return Number(obj) % 2 === 0;
		  }
		}
		// 等同于
		const Even = {
		  [Symbol.hasInstance](obj) {
		    return Number(obj) % 2 === 0;
		  }
		};

		1 instanceof Even; 		// false
		2 instanceof Even; 		// true
		12345 instanceof Even; 	// false
	</script>
	6.Symbol.isConcatSpreadable
	<script type="text/javascript">
		// 定义当前 对象/数组 作为concat的参数时,是否可展开.
		// 数组
		let arr1 = ['c', 'd'];
		['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']
		arr1[Symbol.isConcatSpreadable] // undefined

		let arr2 = ['c', 'd'];
		arr2[Symbol.isConcatSpreadable] = false;
		['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']

		// 对象
		let obj = {length: 2, 0: 'c', 1: 'd'};
		['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']

		obj[Symbol.isConcatSpreadable] = true;
		['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e']
	</script>
	7.Symbol.species
	<script type="text/javascript">
		// 重写衍生对象的 instanceof/自身构造函数 的指向
		// Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数
		class MyArray extends Array {
		}
		const a = new MyArray(1, 2, 3);
		const b = a.map(x => x);
		const c = a.filter(x => x > 1);

		a instanceof MyArray; // true
		b instanceof MyArray; // true
		c instanceof MyArray; // true

		class ItArray extends Array {
		  static get [Symbol.species]() { return Array; }
		}
		const e = new ItArray(1, 2, 3);
		const f = e.map(x => x);
		const g = e.filter(x => x > 1);

		e instanceof ItArray; // true
		f instanceof ItArray;	// false
		g instanceof ItArray;	// false
	</script>
	8.Symbol.match
	<script type="text/javascript">
		// 当前对象作为match的函数的参数时 重写match函数
		

		String.prototype.match(regexp);
		// 等同于
		regexp[Symbol.match](this);

		// RegExp 中拥有 Symbol.match 函数的的实现
		// /a/g[Symbol.match]('abc') 调用 /a/g 的 Symbol.match 函数
		'abc'.match(/a/g) === /a/g[Symbol.match]('abc');

		class MyMatcher {
		  [Symbol.match](string) {
		    return 'hello world'.indexOf(string);
		  }
		}

		'e'.match(new MyMatcher()) // 1
	</script>
	9.Symbol.replace
	<script type="text/javascript">
		// 指向一个方法，当该对象被 String.prototype.replace 方法调用时，会返回该方法的返回值
		// 重写replace函数
		String.prototype.replace(searchValue, replaceValue);
		// 等同于
		searchValue[Symbol.replace](this, replaceValue);

		const x = {
			[Symbol.replace](...s){
				console.log(s);
			}
		};
		'Hello'.replace(x, 'World') // ["Hello", "World"]
	</script>
	10.Symbol.search
	<script type="text/javascript">
		// 当该对象被String.prototype.search方法调用时，会返回该方法的返回值
		// 重写search函数
		String.prototype.search(regexp)
		// 等同于
		regexp[Symbol.search](this)

		class MySearch {
		  constructor(value) {
		    this.value = value;
		  }
		  [Symbol.search](string) {
		    return string.indexOf(this.value);
		  }
		}
		'foobar'.search(new MySearch('foo')) // 0
	</script>
	11.Symbol.split
	<script type="text/javascript">
		// 重写split函数
		String.prototype.split(separator, limit)
		// 等同于
		separator[Symbol.split](this, limit)
		class MySplitter {
		  constructor(value) {
		    this.value = value;
		  }
		  [Symbol.split](string) {
		    let index = string.indexOf(this.value);
		    if (index === -1) {
		      return string;
		    }
		    return [
		      string.substr(0, index),
		      string.substr(index + this.value.length)
		    ];
		  }
		}

		'foobar'.split(new MySplitter('foo'))
		// ['', 'bar']

		'foobar'.split(new MySplitter('bar'))
		// ['foo', '']

		'foobar'.split(new MySplitter('baz'))
		// 'foobar'
	</script>
	12.Symbol.iterator
	<script type="text/javascript">
		// 重写默认遍历器方法( for...of )
		const myIterable = {};
		myIterable[Symbol.iterator] = function* () {
		  yield 1;
		  yield 2;
		  yield 3;
		};

		[...myIterable] // [1, 2, 3]
		class Collection {
		  *[Symbol.iterator]() {
		    let i = 0;
		    while(this[i] !== undefined) {
		      yield this[i];
		      ++i;
		    }
		  }
		}

		let myCollection = new Collection();
		myCollection[0] = 1;
		myCollection[1] = 2;

		for(let value of myCollection) {
		  console.log(value);
		}
		// 1
		// 2
	</script>
	13.Symbol.toPrimitive
	<script type="text/javascript">
		// 数据类型转换函数重写,返回自定义函数的返回值
		// 拥有三种情况 number string 和 default
		// 没有 隐式/强制 类型转换时值为default.
		// hint === string 隐式类型转换得不到,只能通过强转(目前)
		let obj = {
		  [Symbol.toPrimitive](hint) {
		    switch (hint) {
		      case 'number':
		        return 123;
		      case 'string':
		        return 'str';
		      case 'default':
		        return 'default';
		      default:
		        throw new Error();
		     }
		   }
		};

		1 + a;			// "1default"
		2 * a;			// 246
		'3' * a;		// 369
		'4' + a;		// "4default"
		String(a); 	// "str"
	</script>
	14.Symbol.toStringTag
	<script type="text/javascript">
		//  重写 对象的toString函数
		//  实际和 Object.prototype.toString 类型判断返回值 关系不大
		// 例一
		({[Symbol.toStringTag]: 'Foo'}.toString())
		// "[object Foo]"

		// 例二
		class Collection {
		  get [Symbol.toStringTag]() {
		    return 'xxx';
		  }
		}
		let x = new Collection();
		Object.prototype.toString.call(x) // "[object xxx]"

		// ES6 新增内置对象的Symbol.toStringTag属性值如下。
		/*
		JSON[Symbol.toStringTag]：'JSON'
		Math[Symbol.toStringTag]：'Math'
		Module 对象M[Symbol.toStringTag]：'Module'
		ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'
		DataView.prototype[Symbol.toStringTag]：'DataView'
		Map.prototype[Symbol.toStringTag]：'Map'
		Promise.prototype[Symbol.toStringTag]：'Promise'
		Set.prototype[Symbol.toStringTag]：'Set'
		%TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等
		WeakMap.prototype[Symbol.toStringTag]：'WeakMap'
		WeakSet.prototype[Symbol.toStringTag]：'WeakSet'
		%MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'
		%SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'
		%StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'
		Symbol.prototype[Symbol.toStringTag]：'Symbol'
		Generator.prototype[Symbol.toStringTag]：'Generator'
		GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'
		*/
	</script>
	15.Symbol.unscopables
	<script type="text/javascript">
		// 对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。
		// 以对象的形式配置在函数的返回值中
		// 没有 unscopables 时
		class MyClass {
		  foo() { return 1; }
		}

		var foo = function () { return 2; };

		with (MyClass.prototype) {
		  foo(); // 1
		}

		// 有 unscopables 时
		class MyClass {
		  foo() { return 1; }
		  get [Symbol.unscopables]() {
		    return { foo: true };	// {'foo': true}
		  }
		}

		var foo = function () { return 2; };

		with (MyClass.prototype) {
		  foo(); // 2
		}

		// {"copyWithin":true,"entries":true,"fill":true,"find":true,"findIndex":true,"includes":true,"keys":true,"values":true}
		// 数组有 7 个属性，会被with命令排除。
		Array.prototype[Symbol.unscopables];
	</script>

九.Set 和 Map 数据结构
	1.Set
	// 初始化
	<script type="text/javascript">
		// Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
		// 例一
		const set = new Set([1, 2, 3, 4, 4]);
		[...set]		// [1, 2, 3, 4]

		// 例二
		const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
		items.size 	// 5

		// 例三
		const set = new Set(document.querySelectorAll('div'));
		set.size 		// 56
	</script> 
	// add
	<script type="text/javascript">
		const s = new Set();
		[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
		s;	// Set(4) {2, 3, 5, 4}
	</script>
	// 去重
	<script type="text/javascript">
		// 去除数组的重复成员
		[...new Set([1,2,3,4,1,2,3,2])]
		// 去除重复字符串
		[...new Set('ababbc')].join('')	
	</script>
	// Set 属性/函数
	// Array.from方法可以将 Set 结构转为数组。
	<script type="text/javascript">
		let s = new Set();
		// 属性
		Set.prototype.constructor; 	// 构造函数，默认就是Set函数
		Set.prototype.size;					// 返回Set实例的成员总数。

		// 函数
		// 操作函数
		s.add('1');			// 添加某个值，返回 Set 结构本身。
		s.delete('1');	// 删除某个值，返回一个布尔值，表示删除是否成功。
		s.has('1');			// 返回一个布尔值，表示该值是否为Set的成员。
		s.clear();			// 清除所有成员，没有返回值。


		s.size 									// 2
		s.add(1).add(2).add(2);	// 注意2被加入了两次

		s.has(1); 		// true
		s.has(2); 		// true
		s.has(3); 		// false
		s.delete(2);	// true
		s.has(2); 		// false
		s.delete(2);	// false

		// 遍历函数
		s.keys();			// 返回键名的遍历器
		s.values();		// 返回键值的遍历器
		s.entries();	// 返回键值对的遍历器
		s.forEach();	// 使用回调函数遍历每个成员
		// 由于 Set 结构没有键名，只有键值
		let set = new Set(['red', 'green', 'blue']);
		for (let item of set.keys()) console.log(item);	// red green blue
		for (let item of set.keys()) console.log(item);	// red green blue
		for (let item of set.keys()) console.log(item);	// ["red", "red"] ["green", "green"] ["blue", "blue"]

		// Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。
		Set.prototype[Symbol.iterator] === Set.prototype.values; 	// true
		for (let x of set) console.log(x);	// red green blue
		// Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。
		// forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。
		set.forEach((value, key) => console.log(key + ':' + value)); // red:red green:green blue:blue
	</script>
	Set的应用
	// 扩展运算符（...）内部使用for...of循环.
	<script type="text/javascript">
		// 扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。
		let unique = [...new Set([3, 5, 2, 2, 5, 5])];	// [3, 5, 2]
		// 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
		let a = new Set([1, 2, 3]);
		let b = new Set([4, 3, 2]);

		// 并集
		let union = new Set([...a, ...b]);												// Set {1, 2, 3, 4}
		// 交集
		let intersect = new Set([...a].filter(x => b.has(x)));		// set {2, 3}
		// 差集
		let difference = new Set([...a].filter(x => !b.has(x)));	// Set {1}

		// 在遍历操作中改变原来的 Set 结构。
		// 方法一
		let set = new Set([1, 2, 3]);
		set = new Set([...set].map(val => val * 2));
		// set的值是2, 4, 6

		// 方法二
		let set = new Set([1, 2, 3]);
		set = new Set(Array.from(set, val => val * 2));
		// set的值是2, 4, 6
	</script>
	2.WeakSet
	// 初始化/定义
	<script type="text/javascript">
		// WeakSet 结构与 Set 类似
		// WeakSet 的成员只能是对象，而不能是其他类型的值
		// WeakSet 中的对象都是弱引用(垃圾回收机制不考虑 WeakSet 对该对象的引用,
		// 如果其他对象都不再引用该对象，也就是说,如果其他对象都不再引用该对象，
		// 那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。)
		// ES6 规定 WeakSet 不可遍历
		
		// 作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数
		// 注意，是a数组的成员成为 WeakSet 的成员，而不是a数组本身。这意味着，数组的成员只能是对象。
		const a = [[1, 2], [3, 4]];
		const wsa = new WeakSet(a); // WeakSet {[1, 2], [3, 4]}
		
		const b = [3, 4];
		const wsb = new WeakSet(b);	// Uncaught TypeError: Invalid value used in weak set(…)
	</script>
	// 函数
	<script type="text/javascript">
		WeakSet.prototype.add(value);				// 向 WeakSet 实例添加一个新成员。
		WeakSet.prototype.delete(value);		// 清除 WeakSet 实例的指定成员。
		WeakSet.prototype.has(value);				// 返回一个布尔值，表示某个值是否在 

		const ws = new WeakSet();
		const obj = {};
		const foo = {};

		ws.add(window);
		ws.add(obj);

		ws.has(window); 		// true
		ws.has(foo);    		// false

		ws.delete(window);
		ws.has(window);    	// false
	</script>
	// 作用
	<script type="text/javascript">
		// WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
		const foos = new WeakSet()
		class Foo {
		  constructor() {
		    foos.add(this)
		  }
		  method () {
		    if (!foos.has(this)) {
		      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
		    }
		  }
		}
	</script>
	3.Map
	// 初始化
	<script type="text/javascript">
		// Map 数据结构。类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
		const m = new Map();
		const o = {p: 'Hello World'};
		m.set(o, 'content')
		m.get(o) // "content"
		m.has(o) // true
		m.delete(o) // true
		m.has(o) // false
		// 数组作为参数实例化
		const map = new Map([
		  ['name', '张三'],
		  ['title', 'Author']
		]);
		map.size // 2
		map.has('name') // true
		map.get('name') // "张三"
		map.has('title') // true
		map.get('title') // "Author"
		// Map构造函数接受数组作为参数，实际上执行的是下面的算法。
		const items = [
		  ['name', '张三'],
		  ['title', 'Author']
		];
		const map = new Map();
		items.forEach(
		  ([key, value]) => map.set(key, value)
		);
		// 如果对同一个键多次赋值，后面的值将覆盖前面的值。
		const map = new Map();
		map
		.set(1, 'aaa')
		.set(1, 'bbb');
		map.get(1) // "bbb"
		// 如果读取一个未知的键，则返回undefined
		new Map().get('asfddfsasadf') // undefined
		// 只有对同一个对象的引用，Map 结构才将其视为同一个键
		const map = new Map();
		map.set(['a'], 555);
		map.get(['a']) // undefined

		// 原始值的初始化
		let map = new Map();
		map.set(-0, 123);
		map.get(+0) // 123
		map.set(true, 1);
		map.set('true', 2);
		map.get(true) // 1
		map.set(undefined, 3);
		map.set(null, 4);
		map.get(undefined) // 3
		map.set(NaN, 123);
		map.get(NaN) // 123
	</script>
	// 属性/函数
	<script type="text/javascript">
		// size属性返回 Map 结构的成员总数。
		// set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是当前的Map对象，因此可以采用链式写法。
		// get方法读取key对应的键值，如果找不到key，返回undefined。
		// has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
		// delete方法删除某个键，返回true。如果删除失败，返回false。
		// clear方法清除所有成员，没有返回值。
		
		keys();			// 返回键名的遍历器。
		values();		// 返回键值的遍历器。
		entries();	// 返回所有成员的遍历器。
		forEach();	// 遍历 Map 的所有成员。
		const map = new Map([
		  ['F', 'no'],
		  ['T',  'yes'],
		]);

		for (let key of map.keys()) console.log(key);											// "F" "T"
		for (let value of map.values())  console.log(value); 							// "no" "yes"
		for (let item of map.entries()) console.log(item[0], item[1]);		// "F" "no"		"T" "yes"
		for (let [key, value] of map.entries())  console.log(key, value);	// "F" "no"		"T" "yes"
		// 等同于使用map.entries()
		for (let [key, value] of map) console.log(key, value);						// "F" "no"		"T" "yes"
	</script>
	// map的使用
	<script type="text/javascript">
		// 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。
		const map0 = new Map()
		  .set(1, 'a')
		  .set(2, 'b')
		  .set(3, 'c');
		const map1 = new Map(
		  [...map0].filter(([k, v]) => k < 3)
		);

		// 产生 Map 结构 {1 => 'a', 2 => 'b'}
		const map2 = new Map(
		  [...map0].map(([k, v]) => [k * 2, '_' + v])
		);

		// Map 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。
		map.forEach(function(value, key, map) {
		  console.log("Key: %s, Value: %s", key, value);
		});

		// forEach方法还可以接受第二个参数，用来绑定this
		const reporter = {
		  report: function(key, value) {
				console.log("Key: %s, Value: %s", key, value);
			}
		};

		map.forEach(function(value, key, map) {
		  this.report(key, value);
		}, reporter);
	</script>
	4.WeakMap
	// 初始化
	<script type="text/javascript">
		// WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
		const map = new WeakMap();
		map.set(1, 2)
		// TypeError: 1 is not an object!
		map.set(Symbol(), 2)
		// TypeError: Invalid value used as weak map key
		map.set(null, 2)
		// TypeError: Invalid value used as weak map key
	</script>
	// 语法
	<script type="text/javascript">
		// 只有四个方法可用：get()、set()、has()、delete()。
	</script>

十.Proxy
	<script type="text/javascript">
		// Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

		let a = {};
		var obj = new Proxy(a, {
		  get: function (target, key, receiver) {
		    console.log(`getting ${key}!`);
		    return Reflect.get(target, key, receiver);
		  },
		  set: function (target, key, value, receiver) {
		    console.log(`setting ${key}!`);
		    return Reflect.set(target, key, value, receiver);
		  }
		});

		obj.count = 1;	
		// setting count!
		// 1
		a.count = 1;
		// 1
		
		++obj.count;
		// getting count!
		// setting count!
		// 2
		++a.count;
		// 3
	</script>
	// 实例方法
	// get();
	<script type="text/javascript">
		// git 拦截
		// target 当前拦截的对象
		// property 读取的属性
		// 当前proxy(代理)对象
		// get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。
		var person = {
		  name: "张三"
		};
		var proxy = new Proxy(person, {
		  get: function(target, property,proxyTarget) {
		    if (property in target) {
		      return target[property];
		    } else {
		      throw new ReferenceError("Property \"" + property + "\" does not exist.");
		    }
		  }
		});
		proxy.name; // "张三"
		proxy.age; 	// 抛出一个错误
		// get方法可以继承。
		let proto = new Proxy({}, {
		  get(target, propertyKey, receiver) {
		    console.log('GET ' + propertyKey);
		    return target[propertyKey];
		  }
		});

		let obj = Object.create(proto);
		obj.foo // "GET foo"
		// get方法的第三个参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。
		// proxy对象的getReceiver属性是由proxy对象提供的，所以receiver指向proxy对象。
		const proxy = new Proxy({}, {
		  get: function(target, property, receiver) {
		    return receiver;
		  }
		});
		// d对象本身没有a属性，所以读取d.a的时候，会去d的原型proxy对象找。这时，receiver就指向d，代表原始的读操作所在的那个对象。
		proxy.getReceiver === proxy // true 
		const proxy = new Proxy({}, {
		  get: function(target, property, receiver) {
		    return receiver;
		  }
		});

		const d = Object.create(proxy);
		d.a === d // true
		// 链式调用
		var pipe = (function () {
		  return function (value) {
		    var funcStack = [];
		    var oproxy = new Proxy({} , {
		      get : function (target, prototype) {
		        if (prototype === 'get') {
		          return funcStack.reduce(function (val, fn) {
		            return fn(val);
		          },value);
		        }
		        funcStack.push(window[prototype]);
		        return oproxy;
		      }
		    });

		    return oproxy;
		  }
		}());
		var double = n => n * 2;
		var pow    = n => n * n;
		var reverseInt = n => n.toString().split("").reverse().join("") | 0;
		pipe(3).double.pow.reverseInt.get; // 63

		// 通用dom生成函数
		const dom = new Proxy({}, {
		  get(target, property) {
		    return function(attrs = {}, ...children) {
		      const el = document.createElement(property);
		      for (let prop of Object.keys(attrs)) {
		        el.setAttribute(prop, attrs[prop]);
		      }
		      for (let child of children) {
		        if (typeof child === 'string') {
		          child = document.createTextNode(child);
		        }
		        el.appendChild(child);
		      }
		      return el;
		    }
		  }
		});
		const el = dom.div({},
		  'Hello, my name is ',
		  dom.a({href: '//example.com'}, 'Mark'),
		  '. I like:',
		  dom.ul({},
		    dom.li({}, 'The web'),
		    dom.li({}, 'Food'),
		    dom.li({}, '…actually that\'s it')
		  )
		);
		document.body.appendChild(el);
	</script>
	// set()
	<script type="text/javascript">
		// set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选.
		// 假定Person对象有一个age属性，该属性应该是一个不大于 200 的整数，那么可以使用Proxy保证age的属性值符合要求。
		let validator = {
		  set: function(obj, prop, value) {
		    if (prop === 'age') {
		      if (!Number.isInteger(value)) {
		        throw new TypeError('The age is not an integer');
		      }
		      if (value > 200) {
		        throw new RangeError('The age seems invalid');
		      }
		    }
		    // 对于满足条件的 age 属性以及其他属性，直接保存
		    obj[prop] = value;
		  }
		};
		let person = new Proxy({}, validator);
		person.age = 100;
		person.age // 100
		person.age = 'young' // 报错
		person.age = 300 // 报错	

		// 在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。
		const handler = {
		  get (target, key) {
		    invariant(key, 'get');
		    return target[key];
		  },
		  set (target, key, value) {
		    invariant(key, 'set');
		    target[key] = value;
		    return true;
		  }
		};
		function invariant (key, action) {
		  if (key[0] === '_') {
		    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
		  }
		}
		const target = {};
		const proxy = new Proxy(target, handler);
		proxy._prop
		// Error: Invalid attempt to get private "_prop" property
		proxy._prop = 'c'
		// Error: Invalid attempt to set private "_prop" property		
		
		// set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是proxy实例本身
		const handler = {
		  set: function(obj, prop, value, receiver) {
		    obj[prop] = receiver;
		  }
		};
		const proxy = new Proxy({}, handler);
		proxy.foo = 'bar';
		proxy.foo === proxy // true

		// 设置myObj.foo属性的值时，myObj并没有foo属性，因此引擎会到myObj的原型链去找foo属性。myObj的原型对象proxy是一个 Proxy 实例，设置它的foo属性会触发set方法。这时，第四个参数receiver就指向原始赋值行为所在的对象myObj。
		const handler = {
		  set: function(obj, prop, value, receiver) {
		    obj[prop] = receiver;
		  }
		};
		const proxy = new Proxy({}, handler);
		const myObj = {};
		Object.setPrototypeOf(myObj, proxy);

		myObj.foo = 'bar';
		myObj.foo === myObj // true		

		// 注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
		const obj = {};
		Object.defineProperty(obj, 'foo', {
		  value: 'bar',
		  writable: false,
		});
		const handler = {
		  set: function(obj, prop, value, receiver) {
		    obj[prop] = 'baz';
		  }
		};
		const proxy = new Proxy(obj, handler);
		proxy.foo = 'baz';
		proxy.foo // "bar"

		// 注意，严格模式下，set代理如果没有返回true，就会报错。
		// 严格模式下，set代理返回false或者undefined，都会报错。
		'use strict';
		const handler = {
		  set: function(obj, prop, value, receiver) {
		    obj[prop] = receiver;
		    // 无论有没有下面这一行，都会报错
		    return false;
		  }
		};
		const proxy = new Proxy({}, handler);
		proxy.foo = 'bar';
		// TypeError: 'set' on proxy: trap returned falsish for property 'foo'		
	</script>
	// apply()
	<script type="text/javascript">
		// apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。
		var handler = {
		  apply (target, ctx, args) {
		    return Reflect.apply(...arguments);
		  }
		};
		
		var target = function () { return 'I am the target'; };
		var handler = {
		  apply: function () {
		    return 'I am the proxy';
		  }
		};
		var p = new Proxy(target, handler);
		p();	// "I am the proxy"

		//
		var twice = {
		  apply (target, ctx, args) {
		  	return Reflect.apply(target,ctx,args) * 2;
		    // return Reflect.apply(...arguments) * 2;
		  }
		};
		function sum (left, right) {
		  return left + right;
		};
		var proxy = new Proxy(sum, twice);
		proxy(1, 2) // 6
		proxy.call(null, 5, 6) // 22
		proxy.apply(null, [7, 8]) // 30

		// 直接调用Reflect.apply方法，也会被拦截。
		Reflect.apply(proxy, null, [9, 10]) // 38
	</script>
	// has()
	<script type="text/javascript">
		// has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
		// has方法可以接受两个参数，分别是目标对象、需查询的属性名。
		// 使用has方法隐藏某些属性，不被in运算符发现。
		var handler = {
		  has (target, key) {
		    if (key[0] === '_') {
		      return false;
		    }
		    return key in target;
		  }
		};
		var target = { _prop: 'foo', prop: 'foo' };
		var proxy = new Proxy(target, handler);
		'_prop' in proxy // false

		// 如果原对象不可配置或者禁止扩展，这时has拦截会报错。
		var obj = { a: 10 };
		Object.preventExtensions(obj);

		var p = new Proxy(obj, {
		  has: function(target, prop) {
		    return false;
		  }
		});
		'a' in p // TypeError is thrown		

		// has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。
		// 虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。
		// has拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没有被for...in循环所排除。
		let stu1 = {name: '张三', score: 59};
		let stu2 = {name: '李四', score: 99};

		let handler = {
		  has(target, prop) {
		    if (prop === 'score' && target[prop] < 60) {
		      console.log(`${target.name} 不及格`);
		      return false;
		    }
		    return prop in target;
		  }
		}

		let oproxy1 = new Proxy(stu1, handler);
		let oproxy2 = new Proxy(stu2, handler);

		'score' in oproxy1
		// 张三 不及格
		// false

		'score' in oproxy2
		// true

		for (let a in oproxy1) {
		  console.log(oproxy1[a]);
		}
		// 张三
		// 59

		for (let b in oproxy2) {
		  console.log(oproxy2[b]);
		}
		// 李四
		// 99
	</script>
	// construct()
	<script type="text/javascript">
		// construct方法用于拦截new命令，下面是拦截对象的写法。
		// target：目标对象
		// args：构造函数的参数对象
		// newTarget：创造实例对象时，new命令作用的构造函数, 当前函数的Proxy实例
		var handler = {
		  construct (target, args, newTarget) {
		    return new target(...args);
		  }
		};
		var p = new Proxy(function () {}, {
		  construct: function(target, args) {
		    console.log('called: ' + args.join(', '));
		    return { value: args[0] * 10 };
		  }
		});

		(new p(1)).value
		// "called: 1"
		// 10			
		
		// construct方法返回的必须是一个对象，否则会报错。
		var p = new Proxy(function() {}, {
		  construct: function(target, argumentsList) {
		    return 1;
		  }
		});
		new p() // 报错
		// Uncaught TypeError: 'construct' on proxy: trap returned non-object ('1')
	</script>
	// deleteProperty()
	<script type="text/javascript">
		// deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。
		// target代理对象
		// key 对象的属性
		// deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。
		// 目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。
		var handler = {
		  deleteProperty (target, key) {
		    invariant(key, 'delete');
		    delete target[key];
		    return true;
		  }
		};
		function invariant (key, action) {
		  if (key[0] === '_') {
		    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
		  }
		}

		var target = { _prop: 'foo' };
		var proxy = new Proxy(target, handler);
		delete proxy._prop
		// Error: Invalid attempt to delete private "_prop" property		
	</script>
	// defineProperty()
	<script type="text/javascript">
		// defineProperty方法拦截了Object.defineProperty操作
		// 如果目标对象不可扩展（non-extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。
		// 如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。
		var handler = {
		  defineProperty (target, key, descriptor) {
		    return false;
		  }
		};
		var target = {};
		var proxy = new Proxy(target, handler);
		proxy.foo = 'bar' // 不会生效		
	</script>
	// getOwnPropertyDescriptor()
	<script type="text/javascript">
		// getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。
		var handler = {
		  getOwnPropertyDescriptor (target, key) {
		    if (key[0] === '_') {
		      return;
		    }
		    return Object.getOwnPropertyDescriptor(target, key);
		  }
		};
		var target = { _foo: 'bar', baz: 'tar' };
		var proxy = new Proxy(target, handler);
		Object.getOwnPropertyDescriptor(proxy, 'wat')
		// undefined
		Object.getOwnPropertyDescriptor(proxy, '_foo')
		// undefined
		Object.getOwnPropertyDescriptor(proxy, 'baz')
		// { value: 'tar', writable: true, enumerable: true, configurable: true }		
	</script>
	// getPrototypeOf()
	<script type="text/javascript">
		// getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。
		// Object.prototype.__proto__
		// Object.prototype.isPrototypeOf()
		// Object.getPrototypeOf()
		// Reflect.getPrototypeOf()
		// instanceof
		// getPrototypeOf方法的返回值必须是对象或者null，否则报错。
		// 如果目标对象不可扩展（non-extensible）， getPrototypeOf方法必须返回目标对象的原型对象。
		// getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。
		var proto = {};
		var p = new Proxy({}, {
		  getPrototypeOf(target) {
		    return proto;
		  }
		});
		Object.getPrototypeOf(p) === proto // true		
	</script>
	// isExtensible()
	<script type="text/javascript">
		// isExtensible方法拦截Object.isExtensible操作。
		// 该方法只能返回布尔值，否则返回值会被自动转为布尔值。
		var p = new Proxy({}, {
		  isExtensible: function(target) {
		    console.log("called");
		    return true;
		  }
		});
		Object.isExtensible(p)
		// "called"
		// true	
		
		// 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。
		var p = new Proxy({}, {
		  isExtensible: function(target) {
		    return false;
		  }
		});
		Object.isExtensible(p)
		// Uncaught TypeError: 'isExtensible' on proxy: trap result does not reflect extensibility of proxy target (which is 'true')			
	</script>
	// ownKeys()
	<script type="text/javascript">
		// ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。
		// 使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。
		// 1.目标对象上不存在的属性 2.属性名为Symbol值 3.不可遍历（enumerable）的属性
		// Object.getOwnPropertyNames()
		// Object.getOwnPropertySymbols()
		// Object.keys()
		// for...in循环
		let target = {a: 1,b: 2,c: 3};
		let handler = {
		  ownKeys(target) {
		    return ['a'];
		  }
		};
		let proxy = new Proxy(target, handler);
		Object.keys(proxy); // [ 'a' ]

		// 拦截第一个字符为下划线的属性名。
		let target = {_bar: 'foo',_prop: 'bar',prop: 'baz'};
		let handler = {
		  ownKeys (target) {
		    return Reflect.ownKeys(target).filter(key => key[0] !== '_');
		  }
		};
		let proxy = new Proxy(target, handler);
		for (let key of Object.keys(proxy)) console.log(target[key]);	// "baz"

		// ownKeys方法之中，显式返回 不存在的属性（d）、Symbol 值（Symbol.for('secret')）、不可遍历的属性（key)
		// 结果都被自动过滤掉(被Object.keys过滤掉了)。
		let target = {a: 1,b: 2,c: 3,[Symbol.for('secret')]: '4',};
		Object.defineProperty(target, 'key', {
		  enumerable: false,
		  configurable: true,
		  writable: true,
		  value: 'static'
		});
		let handler = {
		  ownKeys(target) {
		    return ['a', 'd', Symbol.for('secret'), 'key'];
		  }
		};
		let proxy = new Proxy(target, handler);
		Object.keys(proxy); // ['a']
		// 这里是正常返回,并不会触发其他
		let obj = {d:1};
		var p = new Proxy(obj, {
		  ownKeys: function(target) {
		    return ['a', 'b', 'c'];
		  }
		});
		Object.getOwnPropertyNames(p);	// ["a", "b", "c"]

		// ownkeys指定只返回a和b属性，由于obj没有这两个属性，因此for...in循环不会有任何输出。
		const obj = { hello: 'world' };
		const proxy = new Proxy(obj, {
		  ownKeys: function () {
		    return ['a', 'b'];
		  }
		});
		for (let key in proxy) console.log(key); // 没有任何输出

		// ownKeys方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。
		// ownKeys方法虽然返回一个数组，但是每一个数组中有成员不是字符串或 Symbol 值，因此就报错了。
		var obj = {};
		var p = new Proxy(obj, {
		  ownKeys: function(target) {
		    return [123, true, undefined, null, {}, []];
		  }
		});
		Object.getOwnPropertyNames(p)
		// Uncaught TypeError: 123 is not a valid property name		
		 
		// 如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys方法返回，否则报错。
		var obj = {};
		Object.defineProperty(obj, 'a', {
		  configurable: false,
		  enumerable: true,
		  value: 10 }
		);
		var p = new Proxy(obj, {
		  ownKeys: function(target) {
		    return ['b'];
		  }
		});
		Object.getOwnPropertyNames(p)
		// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a'
		
		// 如果目标对象是不可扩展的（non-extensible），这时ownKeys方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。
		var obj = {
		  a: 1
		};
		Object.preventExtensions(obj);
		var p = new Proxy(obj, {
		  ownKeys: function(target) {
		    return ['a', 'b'];
		  }
		});
		Object.getOwnPropertyNames(p)
		// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible
	</script>
	// preventExtensions() 
	<script type="text/javascript">
		// preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。
		// 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。
		// 下面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。
		var proxy = new Proxy({}, {
		  preventExtensions: function(target) {
		    return true;
		  }
		});
		Object.preventExtensions(proxy)
		// Uncaught TypeError: 'preventExtensions' on proxy: trap returned truish but the proxy target is extensible
		// 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions
		var proxy = new Proxy({}, {
		  preventExtensions: function(target) {
		    console.log('called');
		    Object.preventExtensions(target);
		    return true;
		  }
		});
		Object.preventExtensions(proxy)
		// "called"
		// Proxy {}
	</script>
	// setPrototypeOf()
	<script type="text/javascript">
		// setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。
		// 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf方法不得改变目标对象的原型。
		// 实现,只要修改target的原型对象，就会报错。
		var handler = {
		  setPrototypeOf (target, proto) {
		    throw new Error('Changing the prototype is forbidden');
		  }
		};
		var proto = {};
		var target = function () {};
		var proxy = new Proxy(target, handler);
		Object.setPrototypeOf(proxy, proto);
		// Error: Changing the prototype is forbidden
	</script>
	// Proxy.revocable()
	<script type="text/javascript">
		// Proxy.revocable方法返回一个可取消的 Proxy 实例。
		// Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。
		// 当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。
		// Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。
		let target = {};
		let handler = {};
		let {proxy, revoke} = Proxy.revocable(target, handler);
		proxy.foo = 123;
		proxy.foo // 123
		revoke();
		proxy.foo // TypeError: Revoked

	</script>
	// this 问题
	<script type="text/javascript">
		// 在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。
		const target = {
		  m: function () {
		    console.log(this === proxy);
		  }
		};
		const handler = {};
		const proxy = new Proxy(target, handler);
		target.m() // false
		proxy.m()  // true		

		// 由于this指向的变化，导致 Proxy 无法代理目标对象。
		// 目标对象jane的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。
		// 由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。
		const _name = new WeakMap();
		class Person {
		  constructor(name) {
		    _name.set(this, name);
		  }
		  get name() {
		    return _name.get(this);
		  }
		}
		const jane = new Person('Jane');
		jane.name // 'Jane'
		const proxy = new Proxy(jane, {});
		proxy.name // undefined

		// 有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。
		// getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。
		const target = new Date();
		const handler = {};
		const proxy = new Proxy(target, handler);
		proxy.getDate();
		// TypeError: this is not a Date object.
		
		// this绑定原始对象，就可以解决这个问题。
		const target = new Date('2015-01-01');
		const handler = {
		  get(target, prop) {
		    if (prop === 'getDate') {
		      return target.getDate.bind(target);
		    }
		    return Reflect.get(target, prop);
		  }
		};
		const proxy = new Proxy(target, handler);
		proxy.getDate() // 1		
	</script>
	// 实例：Web 服务的客户端
	<script type="text/javascript">
		// Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。
		// 新建了一个 Web 服务的接口，这个接口返回各种数据。
		// Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。
		// 同理，Proxy 也可以用来实现数据库的 ORM 层。
		const service = createWebService('http://example.com/data');
		service.employees().then(json => {
		  const employees = JSON.parse(json);
		  // ···
		});		
		function createWebService(baseUrl) {
		  return new Proxy({}, {
		    get(target, propKey, receiver) {
		      return () => httpGet(baseUrl+'/' + propKey);
		    }
		  });
		}		
	</script>

十一.Reflect
	// 概述
	<script type="text/javascript">
		// Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。
		// 1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上(现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上,也就是说，从Reflect对象上可以拿到语言内部的方法。)
		
		// 2. 修改某些Object方法的返回结果，让其变得更合理
		// 比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误
		// 而Reflect.defineProperty(obj, name, desc)则会返回false。
		// 老写法
		try {
		  Object.defineProperty(target, property, attributes);
		  // success
		} catch (e) {
		  // failure
		}
		// 新写法
		if (Reflect.defineProperty(target, property, attributes)) {
		  // success
		} else {
		  // failure
		}
		
		// 3. 让Object操作都变成函数行为
		// 某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。
		// 老写法
		'assign' in Object // true
		// 新写法
		Reflect.has(Object, 'assign') // true 

		// 4.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法
		// 这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。
		// 也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。
		// 代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。
		Proxy(target, {
		  set: function(target, name, value, receiver) {
		    var success = Reflect.set(target,name, value, receiver);
		    if (success) {
		      console.log('property ' + name + ' on ' + target + ' set to ' + value);
		    }
		    return success;
		  }
		});

		// 代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。
		// 添加的工作，就是将每一个操作输出一行日志。
		var loggedObj = new Proxy(obj, {
		  get(target, name) {
		    console.log('get', target, name);
		    return Reflect.get(target, name);
		  },
		  deleteProperty(target, name) {
		    console.log('delete' + name);
		    return Reflect.deleteProperty(target, name);
		  },
		  has(target, name) {
		    console.log('has' + name);
		    return Reflect.has(target, name);
		  }
		});

		// 有了Reflect对象以后，很多操作会更易读。
		// 老写法
		Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1
		// 新写法
		Reflect.apply(Math.floor, undefined, [1.75]) // 1	
	</script>
	// 静态方法
	<script type="text/javascript">
		// 这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。
		
		// Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
		Reflect.apply(target, thisArg, args)
		
		// Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
		Reflect.construct(target, args)
		
		// Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。
		Reflect.get(target, name, receiver)
		
		// Reflect.set方法设置target对象的name属性等于value。
		Reflect.set(target, name, value, receiver)
		
		// Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。
		// 未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。
		Reflect.defineProperty(target, name, desc)
		
		// Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。
		Reflect.deleteProperty(target, name)
		// Reflect.has方法对应name in obj里面的in运算符。
		Reflect.has(target, name)
		
		// Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
		Reflect.ownKeys(target)
		// Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
		Reflect.isExtensible(target)

		// Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
		Reflect.preventExtensions(target)
		
		// Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。
		Reflect.getOwnPropertyDescriptor(target, name)
		
		// Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
		Reflect.getPrototypeOf(target)
		
		// Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。
		Reflect.setPrototypeOf(target, prototype)		
	</script>
	// Reflect.get(target, name, receiver)
	<script type="text/javascript">
		var myObject = {
		  foo: 1,
		  bar: 2,
		  get baz() {
		    return this.foo + this.bar;
		  },
		}
		Reflect.get(myObject, 'foo') // 1
		Reflect.get(myObject, 'bar') // 2
		Reflect.get(myObject, 'baz') // 3		
		// 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。
		var myObject = {
		  foo: 1,
		  bar: 2,
		  get baz() {
		    return this.foo + this.bar;
		  },
		};
		var myReceiverObject = {
		  foo: 4,
		  bar: 4,
		};
		Reflect.get(myObject, 'baz', receiver) // 8		
		// 如果第一个参数不是对象，Reflect.get方法会报错。
		Reflect.get(1, 'foo') // 报错
		Reflect.get(false, 'foo') // 报错
	</script>
	// Reflect.set(target, name, value, receiver)
	<script type="text/javascript">
		// Reflect.set方法设置target对象的name属性等于value。
		var myObject = {
		  foo: 1,
		  set bar(value) {
		    return this.foo = value;
		  },
		}
		myObject.foo // 1
		Reflect.set(myObject, 'foo', 2);
		myObject.foo // 2
		Reflect.set(myObject, 'bar', 3)
		myObject.foo // 3

		// 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。
		var myObject = {
		  foo: 4,
		  set bar(value) {
		    return this.foo = value;
		  },
		};
		
		Reflect.set(myObject, 'bar', 1);
		myObject.foo // 1

		var myReceiverObject = {foo: 0,};
		Reflect.set(myObject, 'bar', 10, myReceiverObject);
		myObject.foo // 1
		myReceiverObject.foo // 10		

		// 如果 Proxy对象和 Reflect对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了receiver，那么Reflect.set会触发Proxy.defineProperty拦截。
		// Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。
		// 这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。
		// 如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。
		let p = {a: 'a'};
		let handler = {
		  set(target, key, value, receiver) {
		    console.log('set');
		    Reflect.set(target, key, value, receiver)
		  },
		  defineProperty(target, key, attribute) {
		    console.log('defineProperty');
		    Reflect.defineProperty(target, key, attribute);
		  }
		};
		let obj = new Proxy(p, handler);
		obj.a = 'A';
		// set
		// defineProperty
		
		// 如果第一个参数不是对象，Reflect.set会报错。
		Reflect.set(1, 'foo', {}) // 报错
		Reflect.set(false, 'foo', {}) // 报错
	</script>
	// Reflect.has(obj, name)
	<script type="text/javascript">
		// Reflect.has方法对应name in obj里面的in运算符。
		var myObject = {foo: 1};
		// 旧写法
		'foo' in myObject // true
		// 新写法
		Reflect.has(myObject, 'foo') // true		
	</script>
	// Reflect.deleteProperty(obj, name)
	<script type="text/javascript">
		// Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。
		// 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。
		const myObj = { foo: 'bar' };
		// 旧写法
		delete myObj.foo;
		// 新写法
		Reflect.deleteProperty(myObj, 'foo');
	</script>
	// Reflect.construct(target, args)
	<script type="text/javascript">
		// Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
		function Greeting(name) {
		  this.name = name;
		}
		// new 的写法
		const instance = new Greeting('张三');
		// Reflect.construct 的写法
		const instance = Reflect.construct(Greeting, ['张三']);
	</script>
	// Reflect.getPrototypeOf(obj)
	<script type="text/javascript">
		// Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
		const myObj = new FancyThing();
		// 旧写法
		Object.getPrototypeOf(myObj) === FancyThing.prototype;
		// 新写法
		Reflect.getPrototypeOf(myObj) === FancyThing.prototype;

		// Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是.
		// 如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。
		Object.getPrototypeOf(1) // Number {[[PrimitiveValue]]: 0}
		Reflect.getPrototypeOf(1) // 报错		
	</script>
	// Reflect.setPrototypeOf(obj, newProto)
	<script type="text/javascript">
		// Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。
		const myObj = {};
		// 旧写法
		Object.setPrototypeOf(myObj, Array.prototype);
		// 新写法
		Reflect.setPrototypeOf(myObj, Array.prototype);
		myObj.length // 0

		// 如果无法设置目标对象的原型（比如，目标对象禁止扩展），Reflect.setPrototypeOf方法返回false。
		Reflect.setPrototypeOf({}, null); 								// true
		Reflect.setPrototypeOf(Object.freeze({}), null);	// false

		// 如果第一个参数不是对象，Object.setPrototypeOf会返回第一个参数本身，而Reflect.setPrototypeOf会报错。
		Object.setPrototypeOf(1, {});		// 1
		Reflect.setPrototypeOf(1, {});	// TypeError: Reflect.setPrototypeOf called on non-object
		// 如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。
		Object.setPrototypeOf(null, {});	// TypeError: Object.setPrototypeOf called on null or undefined
		Reflect.setPrototypeOf(null, {});	// TypeError: Reflect.setPrototypeOf called on non-object
	</script>
	// Reflect.apply(func, thisArg, args) 
	<script type="text/javascript">
		// Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
		// 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，
		// 但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。
		const ages = [11, 33, 12, 54, 18, 96];
		// 旧写法
		const youngest = Math.min.apply(Math, ages);
		const oldest = Math.max.apply(Math, ages);
		const type = Object.prototype.toString.call(youngest);
		// 新写法
		const youngest = Reflect.apply(Math.min, Math, ages);
		const oldest = Reflect.apply(Math.max, Math, ages);
		const type = Reflect.apply(Object.prototype.toString, youngest, []);
	</script>
	// Reflect.defineProperty(target, propertyKey, attributes)
	<script type="text/javascript">
		// Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。
		// 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, 'foo')。
		function MyDate() {}
		// 旧写法
		Object.defineProperty(MyDate, 'now', {
		  value: () => Date.now()
		});
		// 新写法
		Reflect.defineProperty(MyDate, 'now', {
		  value: () => Date.now()
		});

		// 这个方法可以与Proxy.defineProperty配合使用。
		// Proxy.defineProperty对属性赋值设置了拦截，然后使用Reflect.defineProperty完成了赋值。
		const p = new Proxy({}, {
		  defineProperty(target, prop, descriptor) {
		    console.log(descriptor);
		    return Reflect.defineProperty(target, prop, descriptor);
		  }
		});
		p.foo = 'bar';	// {value: "bar", writable: true, enumerable: true, configurable: true}
		p.foo; 					// "bar"
	</script>
	// Reflect.getOwnPropertyDescriptor(target, propertyKey) 
	<script type="text/javascript">
		// Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。
		// Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，
		// Object.getOwnPropertyDescriptor(1, 'foo')不报错，返回undefined，
		// 而Reflect.getOwnPropertyDescriptor(1, 'foo')会抛出错误，表示参数非法。
		var myObject = {};
		Object.defineProperty(myObject, 'hidden', {
		  value: true,
		  enumerable: false,
		});
		// 旧写法
		var theDescriptor = Object.getOwnPropertyDescriptor(myObject, 'hidden');
		// 新写法
		var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, 'hidden');
	</script>
	// Reflect.isExtensible (target)
	<script type="text/javascript">
		// Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
		const myObject = {};
		// 旧写法
		Object.isExtensible(myObject) // true
		// 新写法
		Reflect.isExtensible(myObject) // true		
		
		// 如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。	
		Object.isExtensible(1) // false
		Reflect.isExtensible(1) // 报错
	</script>
	// Reflect.preventExtensions(target)
	<script type="text/javascript">
		// Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
		var myObject = {};
		// 旧写法
		Object.preventExtensions(myObject) // Object {}
		// 新写法
		Reflect.preventExtensions(myObject) // true

		// 如果参数不是对象，Object.preventExtensions在 ES5 环境报错，在 ES6 环境返回传入的参数，而Reflect.preventExtensions会报错。
		// ES5 环境
		Object.preventExtensions(1) // 报错
		// ES6 环境
		Object.preventExtensions(1) // 1
		// 新写法
		Reflect.preventExtensions(1) // 报错
	</script>
	// Reflect.ownKeys (target)
	<script type="text/javascript">
		// Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
		var myObject = {
		  foo: 1,
		  bar: 2,
		  [Symbol.for('baz')]: 3,
		  [Symbol.for('bing')]: 4,
		};
		// 旧写法
		Object.getOwnPropertyNames(myObject)
		// ['foo', 'bar']
		Object.getOwnPropertySymbols(myObject)
		//[Symbol(baz), Symbol(bing)]
		// 新写法
		Reflect.ownKeys(myObject)
		// ['foo', 'bar', Symbol(baz), Symbol(bing)]
	</script>

十二.Promise
	1.Promise 的含义
	<script type="text/javascript">
		// Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
		// 它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。
		
		// Promise对象有以下两个特点。
		// 1.对象的状态不受外界影响。
		// Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
		// 只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。
		// 
		// 2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。
		// Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。
		// 只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。
		// 如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
	</script>
	2.基本用法
	<script type="text/javascript">
		// ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。
		// Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
		// 它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
		// resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
		// reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
		const promise = new Promise(function(resolve, reject) {
		  // ... some code
		  if (/* 异步操作成功 */){
		    resolve(value);
		  } else {
		    reject(error);
		  }
		});

		// Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
		// then方法可以接受两个回调函数作为参数。
		// 第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。
		// 其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。
		promise.then(function(value) {
		  // success
		}, function(error) {
		  // failure
		});

		// 一个Promise对象的简单例子。
		function timeout(ms) {
		  return new Promise((resolve, reject) => {
		    setTimeout(resolve, ms, 'done');
		  });
		}
		timeout(100).then((value) => {
		  console.log(value);
		});		

		// Promise 新建后就会立即执行。
		// Promise 新建后立即执行，所以首先输出的是Promise。
		// 然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。
		let promise = new Promise(function(resolve, reject) {
		  console.log('Promise');
		  resolve();
		});
		promise.then(function() {
		  console.log('resolved.');
		});
		console.log('Hi!');
		// Promise
		// Hi!
		// resolved		
	
		// 异步加载图片的例子。
		// 使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。
		function loadImageAsync(url) {
		  return new Promise(function(resolve, reject) {
		    const image = new Image();
		    image.onload = function() {
		      resolve(image);
		    };
		    image.onerror = function() {
		      reject(new Error('Could not load image at ' + url));
		    };
		    image.src = url;
		  });
		}

		// 用Promise对象实现的 Ajax 操作的例子。
		// getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。
		// 需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。
		// 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。
		// reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例.
		const getJSON = function(url) {
		  const promise = new Promise(function(resolve, reject){
		    const handler = function() {
		      if (this.readyState !== 4) {
		        return;
		      }
		      if (this.status === 200) {
		        resolve(this.response);
		      } else {
		        reject(new Error(this.statusText));
		      }
		    };
		    const client = new XMLHttpRequest();
		    client.open("GET", url);
		    client.onreadystatechange = handler;
		    client.responseType = "json";
		    client.setRequestHeader("Accept", "application/json");
		    client.send();

		  });
		  return promise;
		};
		getJSON("/posts.json").then(function(json) {
		  console.log('Contents: ' + json);
		}, function(error) {
		  console.error('出错了', error);
		});

		// resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。
		// p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。
		const p1 = new Promise(function (resolve, reject) {
		  // ...
		});
		const p2 = new Promise(function (resolve, reject) {
		  // ...
		  resolve(p1);
		})

		// 这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。
		// 如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；
		// 如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。
		// 
		// p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。
		// 由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。
		// 所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。
		const p1 = new Promise(function (resolve, reject) {
		  setTimeout(() => reject(new Error('fail')), 3000)
		})
		const p2 = new Promise(function (resolve, reject) {
		  setTimeout(() => resolve(p1), 1000)
		})
		p2.then(result => console.log(result)).catch(error => console.log(error)); // Error: fail		

		// 调用resolve或reject并不会终结 Promise 的参数函数的执行。
		// 代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。
		// 这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。
		new Promise((resolve, reject) => {
		  resolve(1);
		  console.log(2);
		}).then(r => {
		  console.log(r);
		});
		console.log(3);
		// 2
		// 3
		// 1 
		
		// 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。
		// 所以，最好在它们前面加上return语句，这样就不会有意外。
		new Promise((resolve, reject) => {
		  return resolve(1);
		  // 后面的语句不会执行
		  console.log(2);
		})
	</script>
	3.Promise.prototype.then()
	<script type="text/javascript">
		// Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。
		// 它的作用是为 Promise 实例添加状态改变时的回调函数。
		// 前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。
		
		// then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。
		// 因此可以采用链式写法，即then方法后面再调用另一个then方法。
		// 代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。
		getJSON("/posts.json").then(function(json) {
		  return json.post;
		}).then(function(post) {
		  // ...
		});

		// 采用链式的then，可以指定一组按照次序调用的回调函数。
		// 这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。
		// 第一个then方法指定的回调函数，返回的是另一个Promise对象。
		// 这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。
		// 如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。
		getJSON("/post/1.json").then(function(post) {
		  return getJSON(post.commentURL);
		}).then(function funcA(comments) {
		  console.log("resolved: ", comments);
		}, function funcB(err){
		  console.log("rejected: ", err);
		});

		// 采用箭头函数
		getJSON("/post/1.json").then(
		  post => getJSON(post.commentURL)
		).then(
		  comments => console.log("resolved: ", comments),
		  err => console.log("rejected: ", err)
		);
	</script>
	4.Promise.prototype.catch()
	<script type="text/javascript">
		// Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。
		// getJSON方法返回一个 Promise 对象，
		// 如果该对象状态变为resolved，则会调用then方法指定的回调函数；
		// 如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。
		// 另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。
		getJSON('/posts.json').then(function(posts) {
		  // ...
		}).catch(function(error) {
		  // 处理 getJSON 和 前一个回调函数运行时发生的错误
		  console.log('发生错误！', error);
		});		

		p.then((val) => console.log('fulfilled:', val)).catch((err) => console.log('rejected', err));
		// 等同于
		p.then((val) => console.log('fulfilled:', val)).then(null, (err) => console.log("rejected:", err));		

		// promise抛出一个错误，就被catch方法指定的回调函数捕获
		// 可以发现reject方法的作用，等同于抛出错误。
		// 下面写法是等价的
		// 写法一
		const promise = new Promise(function(resolve, reject) {
		  try {
		    throw new Error('test');
		  } catch(e) {
		    reject(e);
		  }
		});
		promise.catch(function(error) {
		  console.log(error);
		});

		// 写法二
		const promise = new Promise(function(resolve, reject) {
		  reject(new Error('test'));
		});
		promise.catch(function(error) {
		  console.log(error);
		});

		// 如果 Promise 状态已经变成resolved，再抛出错误是无效的
		// Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。
		const promise = new Promise(function(resolve, reject) {
		  resolve('ok');
		  throw new Error('test');
		});
		promise.then(function(value) { console.log(value) }).catch(function(error) { console.log(error) });	// ok

		// Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。
		// ，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。
		getJSON('/post/1.json').then(function(post) {
		  return getJSON(post.commentURL);
		}).then(function(comments) {
		  // some code
		}).catch(function(error) {
		  // 处理前面三个Promise产生的错误
		});		

		// 不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。
		// 第二种写法要好于第一种写法，
		// 理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。
		// 因此，建议总是使用catch方法，而不使用then方法的第二个参数。
		// bad
		promise.then(function(data) {}, function(err) {});
		// good
		promise.then(function(data) {}).catch(function(err) {});

		// 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。
		// someAsyncThing函数产生的 Promise 对象，内部有语法错误。
		// 浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。
		// 这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。
		const someAsyncThing = function() {
		  return new Promise(function(resolve, reject) {
		    // 下面一行会报错，因为x没有声明
		    resolve(x + 2);
		  });
		};
		someAsyncThing().then(function() {
		  console.log('everything is great');
		});
		setTimeout(() => { console.log(123) }, 2000);
		// Uncaught (in promise) ReferenceError: x is not defined
		// 123

		// 这个脚本放在服务器执行，退出码就是0（即表示执行成功）。
		// 不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。
		// unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。
		// Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。
		process.on('unhandledRejection', function (err, p) {
		  throw err;
		});

		// Promise 指定在下一轮“事件循环”再抛出错误。
		// 到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。
		onst promise = new Promise(function (resolve, reject) {
		  resolve('ok');
		  setTimeout(function () { throw new Error('test') }, 0)
		});
		promise.then(function (value) { console.log(value) });
		// ok
		// Uncaught Error: test		
		
		// Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。
		// catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。
		const someAsyncThing = function() {
		  return new Promise(function(resolve, reject) {
		    // 下面一行会报错，因为x没有声明
		    resolve(x + 2);
		  });
		};

		// 代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。
		someAsyncThing().catch(error => console.log('oh no', error)).then(() => console.log('carry on'));
		// oh no [ReferenceError: x is not defined]
		// carry on
		
		// 代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。
		Promise.resolve().catch(error => console.log('oh no', error)).then(() => console.log('carry on'));
		// carry on 
	
		// catch方法之中，还能再抛出错误。
		// catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。
		const someAsyncThing = function() {
		  return new Promise(function(resolve, reject) {
		    // 下面一行会报错，因为x没有声明
		    resolve(x + 2);
		  });
		};
		someAsyncThing().then(function() {
		  return someOtherAsyncThing();
		}).catch(function(error) {
		  console.log('oh no', error);
		  // 下面一行会报错，因为 y 没有声明
		  y + 2;
		}).then(function() {
		  console.log('carry on');
		});
		// oh no [ReferenceError: x is not defined]

		// 如果改写一下，结果就不一样了。
		// 第二个catch方法用来捕获前一个catch方法抛出的错误
		someAsyncThing().then(function() {
		  return someOtherAsyncThing();
		}).catch(function(error) {
		  console.log('oh no', error);
		  // 下面一行会报错，因为y没有声明
		  y + 2;
		}).catch(function(error) {
		  console.log('carry on', error);
		});
		// oh no [ReferenceError: x is not defined]
		// carry on [ReferenceError: y is not defined]
	</script>
	5.Promise.prototype.finally()
	<script type="text/javascript">
		// finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
		// 不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。
		promise.then(result => {···}).catch(error => {···}).finally(() => {···});

		// 服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。
		server.listen(port).then(function () {}).finally(server.stop);

		// finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。
		// 这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
		// finally本质上是then方法的特例。
		// 如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。
		promise.finally(() => {});
		// 等同于
		promise.then(result => {return result;},error => {throw error;});

		// 它的实现也很简单
		// 不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。
		Promise.prototype.finally = function (callback) {
		  let P = this.constructor;
		  return this.then(
		    value  => P.resolve(callback()).then(() => value),
		    reason => P.resolve(callback()).then(() => { throw reason })
		  );
		};	

		// finally方法总是会返回原来的值。
		// resolve 的值是 undefined
		Promise.resolve(2).then(() => {}, () => {})

		// resolve 的值是 2
		Promise.resolve(2).finally(() => {})

		// reject 的值是 undefined
		Promise.reject(3).then(() => {}, () => {})

		// reject 的值是 3
		Promise.reject(3).finally(() => {})
	</script>
	6.Promise.all()
	<script type="text/javascript">
		// Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
		// 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例.
		// 如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。
		// （Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）
		// 
		// p的状态由p1、p2、p3决定，分成两种情况。
		// 1.只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
		// 2.只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。
		const p = Promise.all([p1, p2, p3]);

		// 生成一个Promise对象的数组
		// promises是包含 6 个 Promise 实例的数组，
		// 只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。
		const promises = [2, 3, 5, 7, 11, 13].map(function (id) {
		  return getJSON('/post/' + id + ".json");
		});
		Promise.all(promises).then(function (posts) {
		  // ...
		}).catch(function(reason){
		  // ...
		});

		// booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。
		const databasePromise = connectDatabase();
		const booksPromise = databasePromise.then(findAllBooks);
		const userPromise = databasePromise.then(getCurrentUser);
		Promise.all([booksPromise,userPromise]).then(([books, user]) => pickTopRecommentations(books, user));

		// 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。
		// p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。
		// 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。
		const p1 = new Promise((resolve, reject) => {
		  resolve('hello');
		}).then(result => result).catch(e => e);
		const p2 = new Promise((resolve, reject) => {
		  throw new Error('报错了');
		}).then(result => result).catch(e => e);
		Promise.all([p1, p2]).then(result => console.log(result)).catch(e => console.log(e));
	
		// 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。
		const p1 = new Promise((resolve, reject) => {
		  resolve('hello');
		}).then(result => result);
		const p2 = new Promise((resolve, reject) => {
		  throw new Error('报错了');
		}).then(result => result);
		Promise.all([p1, p2]).then(result => console.log(result)).catch(e => console.log(e));	// Error: 报错了
	</script>
	7.Promise.race()
	<script type="text/javascript">
		// Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
		// 只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
		// Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，
		// 就会先调用Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。
		const p = Promise.race([p1, p2, p3]);

		// 如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。
		// 如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。
		const p = Promise.race([fetch('/resource-that-may-take-a-while'),
		  new Promise(function (resolve, reject) {
		    setTimeout(() => reject(new Error('request timeout')), 5000)
		  })
		]);
		p.then(console.log).catch(console.error);		





		const p = Promise.race([
		  new Promise(function (resolve, reject) {
				console.log("111111");
		    resolve();
		  }),
		  new Promise(function (resolve, reject) {
				console.log("222222");
		    setTimeout(() => {
					console.log("333333");
					reject(new Error('request timeout'));		
				}, 5000)
		  })
		]);
		p.then(_ => console.log(">>>",_)).catch(_ => console.log("<<<",_));	
		// 111111
		// 222222
		// >>> undefined
		// 333333
		 
		const p = Promise.race([
		  new Promise(function (resolve, reject) {
				console.log("111111");
		    setTimeout(_ => {
		    	console.log("444444");
		    	resolve();
		    },10000);
		  }),
		  new Promise(function (resolve, reject) {
				console.log("222222");
		    setTimeout(() => {
					console.log("333333");
					reject(new Error('request timeout'));		
				}, 5000)
		  })
		]);
		p.then(_ => console.log(">>>",_)).catch(_ => console.log("<<<",_));	
		// 111111
		// 222222
		// >>> undefined
		// 333333 <<< Error: request timeout at setTimeout (<anonymous>:13:13)
		// 444444
	</script>
	8.Promise.resolve()
	<script type="text/javascript">
		// 有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。
		// 将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。
		const jsPromise = Promise.resolve($.ajax('/whatever.json'));

		// Promise.resolve等价于下面的写法。
		Promise.resolve('foo')
		// 等价于
		new Promise(resolve => resolve('foo'))

		// 1.Promise.resolve方法的参数分成四种情况。
		// 参数是一个 Promise 实例
		// 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
		
		// 2.thenable对象指的是具有then方法的对象，比如下面这个对象。
		// Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。	
		// thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。
		let thenable = {
		  then: function(resolve, reject) {
		    resolve(42);
		  }
		};
		let p1 = Promise.resolve(thenable);
		p1.then(function(value) {
		  console.log(value);  // 42
		});

		// 3.参数不是具有then方法的对象，或根本就不是对象
		// 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。
		// 生成一个新的 Promise 对象的实例p。
		// 由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。
		// Promise.resolve方法的参数，会同时传给回调函数。
		const p = Promise.resolve('Hello');
		p.then(function (s){
		  console.log(s)
		});
		// Hello
		
		// 4.不带有任何参数
		// Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。
		// 如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。
		const p = Promise.resolve();
		p.then(function () {});

		// 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。
		// setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。
		setTimeout(function () {
		  console.log('three');
		}, 0);
		Promise.resolve().then(function () {
		  console.log('two');
		});
		console.log('one');
		// one
		// two
		// three
	</script>
	9.Promise.reject()
	<script type="text/javascript">
		// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
		// 生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。
		// Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。
		const p = Promise.reject('出错了');
		// 等同于
		const p = new Promise((resolve, reject) => reject('出错了'))

		p.then(null, function (s) {
		  console.log(s)
		});
		// 出错了

		// Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。
		const thenable = {
		  then(resolve, reject) {
		    reject('出错了');
		  }
		};
		Promise.reject(thenable).catch(e => {console.log(e === thenable)});	// true
	</script>
	10.应用
	<script type="text/javascript">
		// 加载图片
		// 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。
		const preloadImage = function (path) {
		  return new Promise(function (resolve, reject) {
		    const image = new Image();
		    image.onload  = resolve;
		    image.onerror = reject;
		    image.src = path;
		  });
		};

		// Generator 函数与 Promise 的结合
		// 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。
		//  Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。
		function getFoo () {
		  return new Promise(function (resolve, reject){
		    resolve('foo');
		  });
		}
		const g = function* () {
		  try {
		    const foo = yield getFoo();
		    console.log(foo);
		  } catch (e) {
		    console.log(e);
		  }
		};
		function run (generator) {
		  const it = generator();
		  function go(result) {
		    if (result.done) return result.value;
		    return result.value.then(function (value) {
		      return go(it.next(value));
		    }, function (error) {
		      return go(it.throw(error));
		    });
		  }
		  go(it.next());
		}
		run(g);
	</script>
	11.Promise.try()
	<script type="text/javascript">
		// 实际开发中，经常遇到一种情况：
		// 不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。
		// 因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。
		Promise.resolve().then(f)

		// 般就会采用这种写法。这样的写法有一个缺点,是如果f是同步函数，那么它会在本轮事件循环的末尾执行。
		// 代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。
		const f = () => console.log('now');
		Promise.resolve().then(f);
		console.log('next');
		// next
		// now		
		
		// 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。
		
		// 第一种写法是用async函数来写。
		const f = () => console.log('now');
		(async () => f())();
		console.log('next');
		// now
		// next

		// 上面代码中,第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。
		(async () => f())().then(_ => _);

		// 需要注意的是，async () => f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。
		(async () => f())().then(_ => _).catch(_ => _);

		// 第二种写法是使用new Promise()。
		// 使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。
		const f = () => console.log('now');
		(
		  () => new Promise(
		    resolve => resolve(f())
		  )
		)();
		console.log('next');
		// now
		// next
		
		// 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。
		const f = () => console.log('now');
		Promise.try(f);
		console.log('next');
		// now
		// next		

		// 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。
		function getUsername(userId) {
		  return database.users.get({id: userId})
		  .then(function(user) {
		    return user.name;
		  });
		}

		// 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。
		database.users.get({id: userId}).then(_ => _).catch(_ => _);

		// 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。
		try {
		  database.users.get({id: userId}).then(_ => _).catch(_ => _);
		} catch (e) {
		  // ...
		}

		// 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。
		// 事实上,Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。
		Promise.try(() => database.users.get({id: userId})).then(_ => _).catch(_ => _);
	</script>

十三.Iterator 和 for...of 循环
	1.Iterator（遍历器）的概念
	<script type="text/javascript">
		// JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。
		// 这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象
		// 。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
		// 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。
		// 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

		// Iterator 的作用有三个：
		// 一是为各种数据结构，提供一个统一的、简便的访问接口；
		// 二是使得数据结构的成员能够按某种次序排列；
		// 三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
		
		// Iterator 的遍历过程是这样的。
		// 1.创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
		// 2.第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
		// 3.第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
		// 4.不断调用指针对象的next方法，直到它指向数据结构的结束位置。
		
		// 每一次调用next方法，都会返回数据结构的当前成员的信息。
		// 具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
		
		// 下面是一个模拟next方法返回值的例子。
		// 定义一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。
		// 对数组['a', 'b']执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。
		// 
		// 指针对象的next方法，用来移动指针。
		// 开始时，指针指向数组的开始位置。
		// 然后，每次调用next方法，指针就会指向数组的下一个成员。
		// 第一次调用，指向a；第二次调用，指向b。
		// 
		// next方法返回一个对象，表示当前数据成员的信息。
		// 这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。
		// 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。		
		var it = makeIterator(['a', 'b']);
		it.next() // { value: "a", done: false }
		it.next() // { value: "b", done: false }
		it.next() // { value: undefined, done: true }
		function makeIterator(array) {
		  var nextIndex = 0;
		  return {
		    next: function() {
		      return nextIndex < array.length ?
		        {value: array[nextIndex++], done: false} :
		        {value: undefined, done: true};
		    }
		  };
		}

		// 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。
		function makeIterator(array) {
		  var nextIndex = 0;
		  return {
		    next: function() {
		      return nextIndex < array.length ?
		        {value: array[nextIndex++]} :
		        {done: true};
		    }
		  };
		}

		// 由于 Iterator 只是把接口规格加到数据结构之上，
		// 所以，遍历器与它所遍历的那个数据结构，实际上是分开的，
		// 完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。
		// 下面是一个无限运行的遍历器对象的例子。
		// 遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。
		// 但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。
		var it = idMaker();
		it.next().value // 0
		it.next().value // 1
		it.next().value // 2
		function idMaker() {
		  var index = 0;
		  return {
		    next: function() {
		      return {value: index++, done: false};
		    }
		  };
		}

		// 如果使用 TypeScript 的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。
		interface Iterable {
		  [Symbol.iterator]() : Iterator,
		}
		interface Iterator {
		  next(value?: any) : IterationResult,
		}
		interface IterationResult {
		  value: any,
		  done: boolean,
		}
	</script>
	2.默认 Iterator 接口
	<script type="text/javascript">
		// Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。
		// 当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。
		// 
		// 一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。
		// 
		// ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。
		// Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。
		// 执行这个函数，就会返回一个遍历器。
		// 至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。
		const obj = {
		  [Symbol.iterator] : function () {
		    return {
		      next: function () {
		        return {
		          value: 1,
		          done: true
		        };
		      }
		    };
		  }
		};		

	</script>

十四.Generator
	<script type="text/javascript">
		
	</script>