<title>Profiles/Profiler</title>
Profiles面板功能的作用主要是监控网页中各种方法执行时间和内存的变化，简单来说它就是Timeline的数字化版本
文件区域
	放置生成的文件

功能区域
	Self time
		函数的本次调用运行的时间，仅仅包含该函数本身的运行时间，不包含它所调用的子函数的时间。
	Total time
		函数的本次调用运行的总时间，包含它所调用的子函数的运行时间。
	Function
		函数名称包含关系
	眼睛
		单独关注某一个函数
	X
		取消关注该函数
	Record JavaScript CPU Profile（函数收集器）
		Chart视图
			按时间先后顺序显示的火焰图。
			视图中的函数颜色不同于其它的面板，这里面的函数颜色标记是随机显示的。然而相同的函数调用颜色标记是相同的。
			其中纵轴表示的函数调用堆栈高度仅仅函数的调用嵌套层次比较深，不表示其重要性很高，
			但是横轴上一个很宽的柱形条则意味着函数的调用需要一个很长的时间去完成，那么你就考虑去做一些优化操作，具体可以参见网络性能优化方案及里面的相关参考文档。
			时间轴
				时间轴底部为内存变化图
			Overview 
				整个录制结果的鸟瞰图（概览），柱形条的高度对应了调用堆栈的深度，也就是说柱形条高度越高，调用堆栈的深度越深。
			Call Stacks 
				在录制过程中被调用的函数的深入分析视图（调用堆栈），横轴表示时间，纵轴表示调用栈，自上而下的表示函数的调用情况。也就是说上面的函数调用在它下面的函数。
			将鼠标移到Call Stacks中的函数上可以显示函数的名称和时间相关的数据，会提供如下信息：
				Name 
					函数名称
				Self time 
					函数的本次调用运行的时间，仅仅包含该函数本身的运行时间，不包含它所调用的子函数的时间。
				Total time 
					函数的本次调用运行的总时间，包含它所调用的子函数的运行时间。
				URL 
					函数定义在文件中所在的位置，其格式为file.js:100，表示函数在file.js文件中的第100行。
				Aggregated self time 
					在这次的录制过程中函数调用运行的总时间，不包含它所调用的子函数的时间。
				Aggregated total time 
					在这次的录制过程中所有的函数调用运行的总时间，包含它所调用的子函数的时间。
				Not optimized 
					如果优化器检测到该函数有潜在的优化空间，那么该函数会被列在这里。
		Heavy(Bottom Up) （自底向上）
			根据对性能的消耗影响列出所有的函数，并可以查看该函数的调用路径。
		Tree(Top Down) (自顶向下) 
			从调用栈的顶端（最初调用的位置）开始，显示调用结构的总体的树状图情况。
	Take Heap Snapshot（内存快照）
		Summary视图
			该视图会显示所有的对象信息，点击其中的一个对象进行展开可查看更详细的实例信息。鼠标移动到某个对象上会显示该对象实例的详情信息。
			Constructor(构造函数)
				表示所有通过该构造函数生成的对象
				在展开构造函数，则会列出该函数相关的所有对象实例，可以查看该对象的Shallow size和Retained size，在@符号后面的数字是该对象的唯一标识ID。
				其中黄色的对象表示在它被某个JS所引用，而红色的对象表示由黄色背景色引用被分离开出的节点。
				这些构造函数都代表什么含义呢？
					(global property) 全局对象（比如window）
						和通过它引用的对象之间的中间对象，如果一个对象是由Person构造函数生成并被全局对象所引用，那么它们的引用路径关系就像这样[global] > (global property) > Person。
						这跟常规的对象之间直接引用相比，采用中间对象主要是考虑性能的原因。全局对象的改变是很频繁的，而非全局变量的属性访问最优化方案对全局变量是不适用的。
					(roots) 
						它们可以是由引擎自己的目标创建的一些引用，这个引擎可以缓存引用的对象，但所有的这些引用都是弱引用，它们不会阻止引用对象被回收。
					(closure) 
						一些函数闭包中的一组对象的引用。
					(array, string, number, regexp) 
						一系属性引用了数组(Array),字符串(String),数字(Number)或正则表达式的对象类型。
					HTMLDivElement, HTMLAnchorElement, DocumentFragment等 
						你的代码中对元素(elements)的引用或者指定的document对象的引用。
	　Distance 
			对象到达GC根的最短距离
			js对象可以互相引用，在某个对象申请了一块内存后，它很可能会被其他对象应用，而其他对象又被另外的对象应用，一层一层.
			但它们的指针都是指向同一块内存的，我们把这最初引用的那块内存就可以成为GC根。
	　Objects Count 
			对象的实例数
	　Shallow size 
			对应构造函数生成的对象的shallow sizes(直接占用内存)总数
			直接占用内存指的是对象本身占用的内存，因为对象在内存中会通过两种方式存在着，
			一种是被一个别的对象保留（我们可以说这个对象依赖别的对象）
			或者被Dom对象这样的原生对象隐含保留
			在这里直接占有内存指的就是前一种
			通常来讲，数组和字符串会保留更多的直接占有内存
	　Retained size 
				展示了对应对象所占用的最大内存
				Retained size是该对象被GC之后所能回收到内存的总和。
				最大内存(Retained size)就是该对象依赖的其他对象所占用的内存。
				在闭包中,每次执行b函数的时候都可以访问到obj，说明内存未被回收 所以对于obj来说直接占用内存[1,2,....n], 而b依赖obj，所obj是b的最大内存。
				如下
				<script type="text/javascript">
					var refA = document.getElementById('refA');
	    		var refB = document.getElementById('refB');//refB引用了refA。它们之间是dom树父节点和子节点的关系。
				</script>
				现在，问题来了，如果我现在在dom中移除div#refA会怎么样呢？
				答案是dom内存依然存在，因为它被js引用。
				那么我把refA变量置为null呢？答案是内存依然存在了。
				因为refB对refA存在引用，所以除非在把refB释放，否则dom节点内存会一直存在浏览器中无法被回收掉.
		Comparison视图
			通过比较多个快照之间的差异来找出内存泄露的对象.
			为了验证某个程序的操作不会引起内存泄露（通常会执行一个操作后再执行一个对应的相反操作，比如打开一个文档后再关闭它，应该是没有产生内存泄露问题的），你可以执行如下步骤：
				1.在执行一个操作之前拍一个快照。
				2.执行一个操作，通过你认为可能会引起内存泄露的一次页面交互操作。
				3.执行一个相反的操作。
				4.拍第二个快照，切换到Comparison视图，并与第一个快照进行对比
		Containment视图
			该视图本质上就是应用程序的对象结构的“鸟瞰图”，允许你去深入分析函数的闭包，了解应用程序底层的内存使用情况。
			这个视图提供了多个入口：
				DOMWindow objects DOMWindow对象，即JS代码全局对象。
				Native objects 浏览器原生对象，比如DOM节点，CSS规则。
				闭包小建议: 在快照的分析中命名函数的闭包相比匿名函数的闭包更容易区分。
		Statistics视图
			该视图是堆快照的总的分布统计情况
	Record Allocation Timeline/Record Heap Allocations(对象跟踪器)
		该工具是可以帮助你追踪JS堆里面的内存泄漏的另一大利器。
		选中Record Allocation Timeline按钮，点击Start按钮之后，执行你认为可能会引起内存泄漏的操作，操作之后点击左上角的停止按钮即可。
		你可以在蓝色竖线上通过缩放来过滤构造器窗格来仅仅显示在指定的时间帧内的被分配的对象。
		录制过程中，在时间线上会出现一些蓝色竖条，这些蓝色竖条代表一个新的内存分配，这个新的内存分配都可以会有潜在的内存泄露问题。
		通过展开对象并点击它的值则可以在Object窗格中查看更多新分配的对象细节。
	Record Allocation Profile简介
		从JS函数角度记录并查看内存的分配信息。
		点击Start按钮，执行你想要去深入分析的页面操作，当你完成你的操作后点击Stop按钮。
		然后会显示一个按JS函数进行内存分配的分解图，默认的视图是Heavy (Bottom Up)，该视图会把最消耗内存的函数显示在最顶端。
